<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Advanced Pole & Permit Map — v3 (Year-3000)</title>

<!-- Core libs -->
<link  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet"/>
<link  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" rel="stylesheet"/>
<link  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" rel="stylesheet"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<!-- Viz stack for the report -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>

<style>
  :root{
    --bg:#05070c; --panel:#070b12; --muted:#a2acbd; --fg:#eef2ff; --border:#162032;
    --chip-pending:#fb923c;   --chip-approved:#34d399; --chip-created:#facc15;
    --chip-na-cannot:#a78bfa; --chip-na-other:#ef4444; --chip-none:#94a3b8;
    --accent:#60a5fa; --glass:rgba(8,12,20,.75);

    /* neon gradients */
    --g1: radial-gradient(1200px 600px at 20% -10%, #0ea5e9 0%, transparent 60%);
    --g2: radial-gradient(900px 500px at 120% 10%, #a855f7 0%, transparent 55%);
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #map{position:fixed; inset:0}
  /* subtle holo aura */
  #bgfx::before,#bgfx::after{content:""; position:fixed; inset:0; pointer-events:none; z-index:1}
  #bgfx::before{background:var(--g1); opacity:.25}
  #bgfx::after{background:var(--g2); opacity:.18}

  /* panels */
  .panel{position:fixed; z-index:910; border:1px solid var(--border); background:var(--glass);
    backdrop-filter: blur(10px) saturate(1.15); border-radius:16px; box-shadow:0 12px 40px rgba(0,0,0,.45)}
  .panel h3{margin:0 0 8px 0; font-size:14px; letter-spacing:.4px}
  .muted{color:var(--muted)}
  .btn{border:1px solid var(--border); background:#0a0f18; color:var(--fg); padding:8px 12px; border-radius:10px; cursor:pointer}
  .btn:hover{background:#0d131f}
  select,input{border:1px solid var(--border); background:#0a0f18; color:var(--fg); padding:8px 10px; border-radius:10px}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .field{display:flex; flex-direction:column; gap:4px}

  #filters{top:16px; left:16px; width:460px; padding:14px}
  #legend{left:16px; bottom:16px; width:340px; padding:12px}
  #tools{top:16px; right:16px; width:360px; padding:12px; display:flex; flex-direction:column; gap:10px}

  /* legend */
  #legend .item{display:flex; align-items:center; gap:10px; margin:6px 0}
  #legend svg{width:22px; height:22px; filter: drop-shadow(0 1px 0 rgba(0,0,0,.4));}
  .swatch{width:16px; height:16px; border:1px solid #000; border-radius:4px}

  /* popups */
  .leaflet-popup-content-wrapper{background:#0a0f18;color:var(--fg);border-radius:12px;border:1px solid var(--border)}
  .leaflet-popup-tip{background:#0a0f18}
  .popup-title{font-weight:800;margin-bottom:4px}
  .popup-sub{color:var(--muted); font-size:12px; margin-bottom:8px}
  .chip{display:inline-block;font-size:11px;border:1px solid #283244;border-radius:999px;padding:2px 8px;margin-left:6px}
  .chip.pending{background:var(--chip-pending);color:#111}
  .chip.approved{background:var(--chip-approved);color:#0b261a}
  .chip.created{background:var(--chip-created);color:#211f06}
  .chip.na_other{background:var(--chip-na-other);color:#fff}
  .chip.na_cannot{background:var(--chip-na-cannot);color:#18132b}

  /* markers and clusters */
  .shape-icon svg{display:block}
  .cluster-pie{border-radius:999px; box-shadow:0 2px 8px rgba(0,0,0,.4); border:2px solid rgba(255,255,255,.75)}

  /* report drawer */
  #report{position:fixed; top:0; right:0; width:min(720px, 48vw); height:100vh; background:#070b12;
    border-left:1px solid var(--border); transform:translateX(100%); transition:transform .28s ease; z-index:950; display:flex; flex-direction:column}
  #report.open{transform:translateX(0)}
  #report header{display:flex; align-items:center; justify-content:space-between; padding:12px 16px; border-bottom:1px solid var(--border)}
  #report main{overflow:auto; padding:14px 16px; display:grid; gap:18px}
  .card{border:1px solid var(--border); border-radius:14px; padding:12px; background:#0a0f18}
  .card h4{margin:0 0 8px 0; font-size:14px}
  canvas, svg{max-width:100%}

  /* toast */
  #toast{position:fixed; left:50%; transform:translateX(-50%); bottom:22px; z-index:980; background:#0a0f18; border:1px solid var(--border); color:var(--fg); padding:8px 12px; border-radius:10px; display:none}
</style>
</head>
<body>
<div id="map"></div>
<div id="bgfx"></div>

<!-- Filters -->
<div id="filters" class="panel">
  <div class="row" style="justify-content:space-between">
    <h3>Advanced Filters</h3>
    <button id="btnReset" class="btn">Reset</button>
  </div>
  <div class="row">
    <div class="field"><small>Owner</small>
      <select id="qOwner"><option value="">All</option><option>BPUB</option><option>AEP</option><option>MVEC</option></select>
    </div>
    <div class="field"><small>Permit Status</small>
      <select id="qStatus">
        <option value="">All</option>
        <option>NONE</option>
        <option>Created - NOT Submitted</option>
        <option>Submitted - Pending</option>
        <option>Approved</option>
        <option>Not Approved - Cannot Attach</option>
        <option>Not Approved - PLA Issues</option>
        <option>Not Approved - MRE Issues</option>
        <option>Not Approved - Other Issues</option>
      </select>
    </div>
    <div class="field" style="flex:1"><small>Search</small><input id="qSearch" placeholder="Job, Tag, SCID, MR…"/></div>
  </div>
  <div class="row" style="margin-top:8px">
    <button id="btnApply" class="btn">Apply</button>
  </div>
</div>

<!-- Legend -->
<div id="legend" class="panel">
  <h3>Legend</h3>
  <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
    <div>
      <div class="muted" style="margin-bottom:6px;">Utility → Shape</div>
      <div class="item"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" fill="#94a3b8" stroke="white" stroke-width="2"/></svg>BPUB (circle)</div>
      <div class="item"><svg viewBox="0 0 24 24"><polygon points="12,4 20,20 4,20" fill="#94a3b8" stroke="white" stroke-width="2"/></svg>AEP (triangle)</div>
      <div class="item"><svg viewBox="0 0 24 24"><polygon points="12,3 21,12 12,21 3,12" fill="#94a3b8" stroke="white" stroke-width="2"/></svg>MVEC (diamond)</div>
    </div>
    <div>
      <div class="muted" style="margin-bottom:6px;">Permit Status → Color</div>
      <div class="item"><span class="swatch" style="background:var(--chip-approved)"></span>Approved</div>
      <div class="item"><span class="swatch" style="background:var(--chip-pending)"></span>Submitted - Pending</div>
      <div class="item"><span class="swatch" style="background:var(--chip-created)"></span>Created - NOT Submitted</div>
      <div class="item"><span class="swatch" style="background:var(--chip-na-cannot)"></span>Not Approved - Cannot Attach</div>
      <div class="item"><span class="swatch" style="background:var(--chip-na-other)"></span>Not Approved - Other/PLA/MRE</div>
      <div class="item"><span class="swatch" style="background:var(--chip-none)"></span>NONE (no permits)</div>
    </div>
  </div>
</div>

<!-- Tools -->
<div id="tools" class="panel">
  <h3>Map Tools</h3>
  <div class="row">
    <button id="btnFit" class="btn">Fit to Poles</button>
    <button id="btnAreas" class="btn">Toggle Job Areas</button>
    <button id="btnReport" class="btn">Open Visual Report</button>
  </div>
  <div class="row">
    <div class="field"><small>View Mode</small>
      <select id="viewMode">
        <option value="standard">Standard</option>
        <option value="heat">Heatmap (severity-weighted)</option>
        <option value="wire">Wireframe (areas only)</option>
      </select>
    </div>
    <div class="field"><small>Cluster</small>
      <select id="clusterMode">
        <option value="on">ON (status pies)</option>
        <option value="off">OFF (every pole)</option>
      </select>
    </div>
    <div class="field" style="min-width:180px">
      <small>Boundary Strictness</small>
      <input id="strict" type="range" min="1" max="8" value="4" />
    </div>
  </div>
  <small class="muted">Heatmap hides markers so the density pops. Strictness 1 = looser, 8 = tightest boundaries.</small>
</div>

<!-- Report drawer -->
<aside id="report">
  <header>
    <strong>Visual Intelligence Report</strong>
    <div class="row">
      <button id="btnPrint" class="btn">Print / Save PDF</button>
      <button id="btnCloseReport" class="btn">Close</button>
    </div>
  </header>
  <main>
    <div class="card"><h4>Sunburst: Job → Status Mix</h4><div id="sunburst"></div></div>
    <div class="card"><h4>Treemap: Owner → Status Volume</h4><div id="treemap" style="height:360px"></div></div>
    <div class="card"><h4>Chord: Owner ↔ Status Flow</h4><svg id="chord" width="640" height="420"></svg></div>
    <div class="card"><h4>Severity Density Spark</h4><canvas id="spark" height="80"></canvas></div>
    <div class="card"><h4>Outlier Scanner (Jobs with extreme Not-Approved ratios)</h4><div id="outliers"></div></div>
  </main>
</aside>

<div id="toast"></div>

<script>
/* ========================= CONFIG & STATE ========================= */
const STATE = {
  poles: [], permits: [], byKey: new Map(),
  cluster: null, markers: [], singlesLayer: L.layerGroup(),
  areas: [], areasVisible: true, bounds: null, heat: null,
};

const STATUS_ORDER = [
  'Not Approved - Cannot Attach',
  'Not Approved - PLA Issues',
  'Not Approved - MRE Issues',
  'Not Approved - Other Issues',
  'Submitted - Pending',
  'Created - NOT Submitted',
  'Approved',
  'NONE'
];

const STATUS_COLOR = s => {
  s = String(s||'').trim();
  const gs = getComputedStyle(document.documentElement);
  if (s==='Submitted - Pending') return gs.getPropertyValue('--chip-pending')||'#fb923c';
  if (s==='Approved') return gs.getPropertyValue('--chip-approved')||'#34d399';
  if (s==='Created - NOT Submitted') return gs.getPropertyValue('--chip-created')||'#facc15';
  if (s==='Not Approved - Cannot Attach') return gs.getPropertyValue('--chip-na-cannot')||'#a78bfa';
  if (s.startsWith('Not Approved -')) return gs.getPropertyValue('--chip-na-other')||'#ef4444';
  if (s==='NONE') return gs.getPropertyValue('--chip-none')||'#94a3b8';
  return gs.getPropertyValue('--chip-none')||'#94a3b8';
};
const statusClass = s=>{
  s=String(s||'').trim();
  if(s==='Submitted - Pending') return 'pending';
  if(s==='Approved') return 'approved';
  if(s==='Created - NOT Submitted') return 'created';
  if(s==='Not Approved - Cannot Attach') return 'na_cannot';
  if(s.startsWith('Not Approved -')) return 'na_other';
  return '';
};
const poleKey = p => `${p.job_name}::${p.tag}::${p.SCID}`;

/* ============================== UI ============================== */
const TOAST = document.getElementById('toast');
function toast(msg, ms=1500){ TOAST.textContent=msg; TOAST.style.display='block'; setTimeout(()=>TOAST.style.display='none', ms); }

/* ============================ MAP BOOT ============================ */
const map = L.map('map', { zoomControl:false, preferCanvas:true });
L.control.zoom({position:'bottomright'}).addTo(map);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',{attribution:'&copy; OpenStreetMap & CARTO'}).addTo(map);

/* Cluster with pie icons */
function pieSVG(counts, total){
  const R=20, C=R+2, S=2*R+4;
  let start=0, paths='';
  STATUS_ORDER.forEach(st=>{
    const n = counts[st]||0; if(!n) return;
    const frac = n/total, end = start + frac*2*Math.PI;
    const x1=C + R*Math.cos(start), y1=C + R*Math.sin(start);
    const x2=C + R*Math.cos(end  ), y2=C + R*Math.sin(end  );
    const large = (end-start)>Math.PI ? 1:0;
    paths += `<path d="M${C},${C} L${x1},${y1} A${R},${R} 0 ${large} 1 ${x2},${y2} z" fill="${STATUS_COLOR(st).trim()}"/>`;
    start=end;
  });
  return `<svg class="cluster-pie" viewBox="0 0 ${S} ${S}" width="${S}" height="${S}">
            ${paths}
            <circle cx="${C}" cy="${C}" r="${R-7}" fill="rgba(7,11,18,.95)" stroke="white" stroke-width="1.2"></circle>
            <text x="${C}" y="${C+4}" text-anchor="middle" font-weight="800" font-size="13" fill="#e5e7eb">${total}</text>
          </svg>`;
}
function makeCluster(){
  if(STATE.cluster){ map.removeLayer(STATE.cluster); }
  STATE.cluster = L.markerClusterGroup({
    disableClusteringAtZoom: 18, spiderfyOnMaxZoom:true,
    iconCreateFunction: cluster=>{
      const children = cluster.getAllChildMarkers();
      const counts = {}; const total=children.length;
      children.forEach(m=>{ const st=m.options.__dominant||'NONE'; counts[st]=(counts[st]||0)+1; });
      return L.divIcon({ html: pieSVG(counts,total), className:'', iconSize:[46,46] });
    }
  });
  map.addLayer(STATE.cluster);
}

/* Marker icons (smaller; MVEC diamond) */
function markerSVG(owner, fill, size=22){
  const stroke='#fff', sw=1.8, half=size/2;
  if(owner==='AEP'){
    return `<svg viewBox="0 0 ${size} ${size}"><polygon points="${half},${sw} ${size-sw},${size-sw} ${sw},${size-sw}" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
  }else if(owner==='MVEC'){
    return `<svg viewBox="0 0 ${size} ${size}"><polygon points="${half},${sw} ${size-sw},${half} ${half},${size-sw} ${sw},${half}" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
  }else{
    return `<svg viewBox="0 0 ${size} ${size}"><circle cx="${half}" cy="${half}" r="${half-3.5}" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
  }
}
function shapeIcon(owner, color){
  return L.divIcon({ className:'shape-icon', html:markerSVG(owner,color), iconSize:[22,22], iconAnchor:[11,11], popupAnchor:[0,-10]});
}

/* ============================= DATA LOAD ============================= */
async function tryFetch(paths){
  for(const p of paths){ try{ const r=await fetch(p); if(r.ok) return await r.json(); }catch(e){} }
  throw new Error('Unable to load: '+paths.join(', '));
}
async function loadData(){
  toast('Loading poles & permits…');
  const [poles, permits] = await Promise.all([
    tryFetch(['poles.json','./poles.json','../poles.json','data/poles.json','./data/poles.json']),
    tryFetch(['permits.json','./permits.json','../permits.json','data/permits.json','./data/permits.json'])
  ]);
  STATE.poles = (poles||[]).filter(p=>typeof p.lat==='number' && typeof p.lon==='number');
  STATE.permits = permits||[];
  const idx=new Map();
  for(const r of STATE.permits){
    const key=`${r.job_name}::${r.tag}::${r.SCID}`;
    if(!idx.has(key)) idx.set(key,[]);
    idx.get(key).push(r);
  }
  STATE.byKey=idx;
  toast(`Loaded ${STATE.poles.length} poles, ${STATE.permits.length} permits`);
}

/* ========================== STATUS / POPUPS ========================== */
function dominantStatusFor(rel){
  if(!rel||!rel.length) return 'NONE';
  const set = new Set(rel.map(r=>String(r.permit_status||'').trim()));
  for(const s of STATUS_ORDER){
    if(s==='NONE') continue;
    if(s.startsWith('Not Approved -')){
      if([...set].some(x=>x.startsWith('Not Approved -'))) return [...set].find(x=>x.startsWith('Not Approved -'));
    } else if(set.has(s)) return s;
  }
  return 'NONE';
}
function statusChipHTML(s){
  if(s==='NONE') return `<span class="chip" style="background:var(--chip-none);color:#0b0c10">NONE</span>`;
  return `<span class="chip ${statusClass(s)}">${s}</span>`;
}
function popupHTML(p, rel){
  const coords = (typeof p.lat==='number' && typeof p.lon==='number') ? `(${p.lat.toFixed(6)}, ${p.lon.toFixed(6)})` : '—';
  const permits = (rel||[]).length ? rel.map(r=>{
    const notes = r.notes ? String(r.notes).replace(/&/g,'&amp;').replace(/</g,'&lt;') : '';
    return `<div style="border:1px solid var(--border);border-radius:10px;padding:8px;margin:6px 0;background:#0a0f18">
      <div class="row" style="justify-content:space-between">
        <div class="small"><code>${r.permit_id||''}</code> ${statusChipHTML(r.permit_status)} ${r.submitted_at?`· ${r.submitted_at}`:''}</div>
      </div>
      ${notes?`<div class="small muted" style="margin-top:6px;white-space:pre-wrap;"><b>Notes:</b> ${notes}</div>`:''}
    </div>`;
  }).join('') : `<div class="small"><span class="chip" style="background:var(--chip-none);color:#0b0c10">NONE</span> <span class="muted">No permits yet.</span></div>`;
  return `<div class="popup">
    <div class="popup-title">${p.job_name||''}</div>
    <div class="popup-sub"><b>Owner:</b> ${p.owner||'—'} · <b>Tag:</b> ${p.tag||'—'} · <b>SCID:</b> ${p.SCID||'—'}</div>
    <div class="small muted" style="margin-bottom:6px"><b>Spec:</b> ${p.pole_spec||'—'} → ${p.proposed_spec||'—'} · <b>MR:</b> ${p.mr_level||'—'} · <b>GPS:</b> ${coords}</div>
    <div class="small muted" style="margin-bottom:4px">Permits</div>
    ${permits}
  </div>`;
}

/* ====================== MARKERS / CLUSTER RENDER ====================== */
function clearMarkers(){
  STATE.cluster && STATE.cluster.clearLayers();
  STATE.singlesLayer.clearLayers();
  STATE.markers = []; STATE.bounds = null;
}
function addMarker(latlng, icon, popup, dominant){
  const m = L.marker(latlng, {icon, __dominant:dominant});
  m.bindPopup(popup, {maxWidth:420,minWidth:320,autoPanPaddingTopLeft:[360,110]});
  STATE.markers.push(m);
  if(!STATE.bounds) STATE.bounds = L.latLngBounds(latlng,latlng); else STATE.bounds.extend(latlng);
  return m;
}
function renderMarkers({cluster=true}={}){
  clearMarkers();
  (cluster ? STATE.cluster : STATE.singlesLayer).addTo(map);
  for(const p of STATE.poles){
    const rel = STATE.byKey.get(poleKey(p))||[];
    const dom = dominantStatusFor(rel);
    const icon = shapeIcon(p.owner, STATUS_COLOR(dom));
    const m = addMarker([p.lat,p.lon], icon, popupHTML(p,rel), dom);
    (cluster ? STATE.cluster : STATE.singlesLayer).addLayer(m);
  }
  if(STATE.bounds) map.fitBounds(STATE.bounds.pad(0.15));
}

/* ============================ AREAS (VISIBLE & SAFE) ============================ */
function colorFromString(s){ let h=0; for(let i=0;i<s.length;i++) h=(h*31+s.charCodeAt(i))>>>0; return `hsl(${h%360} 70% 50%)`; }

function buildRawHulls(pointsByJob, strict=4){
  const raw=new Map();
  const maxEdge = 0.9 - (strict*0.1); // stricter -> smaller edge -> tighter hull
  pointsByJob.forEach((pts,job)=>{
    if(pts.length<3) return;
    const fc=turf.featureCollection(pts.map(c=>turf.point(c)));
    let poly=turf.concave(fc,{maxEdge:Math.max(0.15, maxEdge), units:'kilometers'});
    if(!poly) poly=turf.convex(fc);
    if(!poly) return;
    const simplified=turf.simplify(poly,{tolerance:0.00004 + strict*0.00001, highQuality:true});
    raw.set(job, simplified);
  });
  return raw;
}

/* Never fully erase: if subtraction returns null, keep original; also only subtract overlaps larger than a tiny threshold */
function clipOverlaps(raw){
  const entries=[...raw.entries()].map(([job,poly])=>[job,poly,turf.area(poly)]).sort((a,b)=>b[2]-a[2]);
  const out=[];
  for(let i=0;i<entries.length;i++){
    const [job, poly] = entries[i];
    let clipped = poly;
    for(let j=0;j<i;j++){
      const other = out[j].poly;
      const inter = turf.intersect(clipped, other);
      if(inter){
        if(turf.area(inter) < 30) continue; // ignore tiny slivers
        const diff = turf.difference(clipped, other);
        if(diff) clipped = diff; // if null, keep original so it never disappears
      }
    }
    out.push({job, poly:clipped||poly});
  }
  return out;
}
function drawAreas(polys){
  for(const a of STATE.areas){ map.removeLayer(a.fill); map.removeLayer(a.label); }
  STATE.areas=[];
  polys.forEach(({job,poly})=>{
    const col=colorFromString(job);
    const fill=L.geoJSON(poly,{style:{color:col, weight:1.7, opacity:.95, dashArray:'', fillColor:col, fillOpacity:.12}}).addTo(map);
    const ctr=turf.centerOfMass(poly).geometry.coordinates;
    const label=L.marker([ctr[1],ctr[0]],{interactive:false, icon:L.divIcon({className:'', html:`<div style="font-weight:900;letter-spacing:.4px;font-size:14px;color:#e2e8f0;text-shadow:0 2px 6px rgba(0,0,0,.6)">${job}</div>`})}).addTo(map);
    STATE.areas.push({fill,label});
  });
  if(!STATE.areasVisible){ for(const a of STATE.areas){ map.removeLayer(a.fill); map.removeLayer(a.label); } }
}
function rebuildAreas(currentPoles=null){
  const strict = Number(document.getElementById('strict').value||4);
  const list = currentPoles || STATE.poles;
  const byJob=new Map();
  list.forEach(p=>{
    const job=String(p.job_name||'').trim(); if(!job) return;
    if(!byJob.has(job)) byJob.set(job,[]);
    byJob.get(job).push([p.lon,p.lat]);
  });
  const raw=buildRawHulls(byJob, strict);
  const clipped=clipOverlaps(raw);
  drawAreas(clipped);
}

/* ========================= HEATMAP & VIEW MODES ========================= */
function severityWeight(status){
  const idx = STATUS_ORDER.indexOf(status);
  if(idx<0) return 1;            // fallback
  return 1 + (STATUS_ORDER.length-1-idx); // worst → heaviest
}
function setMarkersVisible(visible){
  if(visible){
    const clus=document.getElementById('clusterMode').value==='on';
    if(clus){ map.addLayer(STATE.cluster); map.removeLayer(STATE.singlesLayer); }
    else { map.addLayer(STATE.singlesLayer); map.removeLayer(STATE.cluster); }
  }else{
    map.removeLayer(STATE.cluster);
    map.removeLayer(STATE.singlesLayer);
  }
}
function updateViewMode(){
  const mode=document.getElementById('viewMode').value;
  if(STATE.heat){ map.removeLayer(STATE.heat); STATE.heat=null; }
  if(mode==='heat'){
    setMarkersVisible(false); // hide markers so heatmap is obvious
    const pts = STATE.poles.map(p=>{
      const rel=STATE.byKey.get(poleKey(p))||[];
      const st=dominantStatusFor(rel);
      return [p.lat,p.lon, severityWeight(st)];
    });
    STATE.heat = L.heatLayer(pts,{radius:28, blur:24, minOpacity:.18, maxZoom:18}).addTo(map);
    // keep areas faint to give spatial structure
    for(const a of STATE.areas){ a.fill.setStyle({fillOpacity:.06, opacity:.5}); }
  }else if(mode==='wire'){
    setMarkersVisible(false);
    for(const a of STATE.areas){ a.fill.setStyle({fillOpacity:.08, opacity:1}); }
  }else{
    setMarkersVisible(true);
    for(const a of STATE.areas){ a.fill.setStyle({fillOpacity:.12, opacity:.95}); }
  }
}

/* ============================== FILTERS ============================== */
function applyFilters(){
  const owner=document.getElementById('qOwner').value;
  const status=document.getElementById('qStatus').value;
  const search=(document.getElementById('qSearch').value||'').toLowerCase();

  const filtered = STATE.poles.filter(p=>{
    if(owner && p.owner!==owner) return false;
    if(search){
      const hay = `${p.job_name} ${p.tag} ${p.SCID} ${p.owner} ${p.mr_level}`.toLowerCase();
      if(!hay.includes(search)) return false;
    }
    if(status){
      const rel=STATE.byKey.get(poleKey(p))||[];
      if(status==='NONE'){ if(rel.length!==0) return false; }
      else if(!rel.some(r=>r.permit_status===status)) return false;
    }
    return true;
  });

  const clusterOn = document.getElementById('clusterMode').value==='on';
  const save = STATE.poles;
  STATE.poles = filtered;
  renderMarkers({cluster:clusterOn});
  if(STATE.areasVisible) rebuildAreas(filtered);
  STATE.poles = save;
  updateViewMode();
}

/* ============================ REPORT v2 ============================ */
let charts=[];
function buildReport(){
  // build data aggregates
  const byJob = new Map();
  const byOwnerStatus = {}; // owner -> status -> count
  const owners = ['BPUB','AEP','MVEC'];
  owners.forEach(o=>byOwnerStatus[o]={});
  STATUS_ORDER.forEach(s=>owners.forEach(o=>byOwnerStatus[o][s]=0));

  const flow = {}; // owner x status matrix
  owners.forEach(o=>flow[o]={}); STATUS_ORDER.forEach(s=>owners.forEach(o=>flow[o][s]=0));

  const density = []; // severity weights for sparkline
  const outliers = []; // job ratios

  for(const p of STATE.poles){
    const rel=STATE.byKey.get(poleKey(p))||[];
    const dom=dominantStatusFor(rel);
    // job bucket
    if(!byJob.has(p.job_name)) byJob.set(p.job_name, {});
    const jb=byJob.get(p.job_name);
    jb[dom]=(jb[dom]||0)+1;

    // owner-status
    const own = owners.includes(p.owner)?p.owner:'OTHER';
    if(!byOwnerStatus[own]) byOwnerStatus[own]={}; // allow OTHER even if rare
    byOwnerStatus[own][dom]=(byOwnerStatus[own][dom]||0)+1;
    if(flow[own]) flow[own][dom]++;

    density.push(severityWeight(dom));
    // outlier score: NA ratio
    const naCount = rel.filter(r=>String(r.permit_status||'').startsWith('Not Approved -')).length;
    const totalPerm = rel.length||1;
    const ratio = naCount/totalPerm;
    if(totalPerm>1 || naCount>=1) outliers.push({job:p.job_name, ratio, na:naCount, total:totalPerm});
  }

  // ---- Sunburst (d3) ----
  const sbRoot = {name:'jobs', children:[...byJob.entries()].map(([job,counts])=>({
    name:job, children:Object.entries(counts).map(([s,c])=>({name:s, value:c}))
  }))};
  d3.select('#sunburst').selectAll('*').remove();
  const width=540, radius=width/2;
  const partition = d3.partition().size([2*Math.PI, radius]);
  const root = d3.hierarchy(sbRoot).sum(d=>d.value||0);
  partition(root);
  const arc = d3.arc().startAngle(d=>d.x0).endAngle(d=>d.x1).innerRadius(d=>d.y0).outerRadius(d=>d.y1-1);
  const svg = d3.select('#sunburst').append('svg').attr('width',width).attr('height',width)
      .append('g').attr('transform',`translate(${radius},${radius})`);
  svg.selectAll('path').data(root.descendants().filter(d=>d.depth))
    .enter().append('path')
      .attr('d', arc)
      .attr('fill', d => d.depth===2 ? STATUS_COLOR(d.data.name).trim() : '#1f2937')
      .attr('stroke', '#0b1220')
      .append('title').text(d=>`${d.ancestors().map(a=>a.data.name).reverse().slice(1).join(' → ')}: ${d.value}`);

  // ---- Treemap (d3) ----
  d3.select('#treemap').selectAll('*').remove();
  const tData = {name:'owners', children:Object.entries(byOwnerStatus).map(([o,dict])=>({
    name:o, children:Object.entries(dict).map(([s,c])=>({name:s, value:c}))
  }))};
  const w = document.getElementById('treemap').clientWidth, h = 360;
  const rootT = d3.hierarchy(tData).sum(d=>d.value||0);
  d3.treemap().size([w,h]).paddingInner(2)(rootT);
  const svgT = d3.select('#treemap').append('svg').attr('width',w).attr('height',h);
  const g = svgT.selectAll('g').data(rootT.leaves()).enter().append('g').attr('transform',d=>`translate(${d.x0},${d.y0})`);
  g.append('rect').attr('width',d=>d.x1-d.x0).attr('height',d=>d.y1-d.y0)
    .attr('fill',d=>STATUS_COLOR(d.data.name).trim()).attr('stroke','#0b1220');
  g.append('text').attr('x',6).attr('y',16).attr('fill','#e5e7eb').attr('font-size','12')
    .text(d=>`${d.parent.data.name} · ${d.data.name} (${d.value})`);

  // ---- Chord (d3) ----
  const chordSVG = d3.select('#chord'); chordSVG.selectAll('*').remove();
  const cw=+chordSVG.attr('width'), ch=+chordSVG.attr('height');
  const matrix = owners.map(o=>STATUS_ORDER.map(s=>(flow[o]?.[s])||0));
  const chord = d3.chord().padAngle(0.03)(d3.transpose(matrix)); // statuses as groups
  const r = Math.min(cw,ch)/2-30;
  const gChord = chordSVG.append('g').attr('transform',`translate(${cw/2},${ch/2})`);
  const color = d3.scaleOrdinal(STATUS_ORDER.map(STATUS_COLOR));
  gChord.selectAll('path.group').data(chord.groups).enter().append('path')
    .attr('class','group')
    .style('fill',d=>color(STATUS_ORDER[d.index]))
    .style('stroke','#0b1220')
    .attr('d',d3.arc().innerRadius(r).outerRadius(r+10));
  gChord.append('g').selectAll('path').data(chord)
    .enter().append('path')
    .attr('d', d3.ribbon().radius(r))
    .style('fill', d=>color(STATUS_ORDER[d.target.index]))
    .style('stroke','#0b1220')
    .append('title').text(d=>`${owners[d.source.index]} → ${STATUS_ORDER[d.target.index]}: ${d.source.value}`);

  // ---- Sparkline (Chart.js) ----
  const ctxS=document.getElementById('spark');
  const seq = density.slice().sort((a,b)=>a-b);
  if(window.sparkChart) window.sparkChart.destroy();
  window.sparkChart = new Chart(ctxS,{type:'line', data:{labels:seq.map((_,i)=>i), datasets:[{data:seq, borderWidth:1.5, pointRadius:0, tension:.3}]},
    options:{plugins:{legend:{display:false}}, scales:{x:{display:false}, y:{display:false}}}});

  // ---- Outliers ----
  const top = outliers.sort((a,b)=>b.ratio-a.ratio).slice(0,10);
  const el = document.getElementById('outliers'); el.innerHTML='';
  top.forEach(o=>{
    const row = document.createElement('div');
    row.className='row'; row.style.cssText='justify-content:space-between; margin:6px 0; border-bottom:1px solid #162032; padding-bottom:6px';
    row.innerHTML = `<div><b>${o.job}</b> <span class="muted">NA ${o.na}/${o.total}</span></div><div style="font-weight:800">${(o.ratio*100).toFixed(1)}%</div>`;
    el.appendChild(row);
  });
}

/* =============================== BOOT =============================== */
(async function(){
  try{
    await loadData();
    makeCluster();
    renderMarkers({cluster:true});
    rebuildAreas();
  }catch(e){ console.error(e); toast('Error loading data', 4000); }
})();

/* =============================== EVENTS =============================== */
document.getElementById('btnFit').addEventListener('click', ()=>{ if(STATE.bounds) map.fitBounds(STATE.bounds.pad(0.15)); });
document.getElementById('btnAreas').addEventListener('click', ()=>{
  STATE.areasVisible=!STATE.areasVisible;
  if(STATE.areasVisible){ for(const a of STATE.areas){ map.addLayer(a.fill); map.addLayer(a.label);} }
  else{ for(const a of STATE.areas){ map.removeLayer(a.fill); map.removeLayer(a.label);} }
});
document.getElementById('clusterMode').addEventListener('change', ()=>{
  const on=document.getElementById('clusterMode').value==='on';
  if(on){ map.removeLayer(STATE.singlesLayer); makeCluster(); renderMarkers({cluster:true}); }
  else { map.removeLayer(STATE.cluster); renderMarkers({cluster:false}); }
  updateViewMode();
});
document.getElementById('viewMode').addEventListener('change', updateViewMode);
document.getElementById('strict').addEventListener('input', ()=>{ rebuildAreas(); updateViewMode(); });

document.getElementById('btnApply').addEventListener('click', applyFilters);
document.getElementById('btnReset').addEventListener('click', ()=>{
  document.getElementById('qOwner').value='';
  document.getElementById('qStatus').value='';
  document.getElementById('qSearch').value='';
  const clus=document.getElementById('clusterMode').value==='on';
  renderMarkers({cluster:clus});
  if(STATE.areasVisible) rebuildAreas();
  updateViewMode();
});
document.getElementById('qSearch').addEventListener('input', ()=>{ clearTimeout(window.__qT); window.__qT=setTimeout(applyFilters,220); });

/* Report drawer */
const reportEl=document.getElementById('report');
document.getElementById('btnReport').addEventListener('click', ()=>{ buildReport(); reportEl.classList.add('open'); });
document.getElementById('btnCloseReport').addEventListener('click', ()=>reportEl.classList.remove('open'));
document.getElementById('btnPrint').addEventListener('click', ()=>window.print());
</script>
</body>
</html>
