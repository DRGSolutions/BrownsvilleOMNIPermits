<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Map Selection</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />

  <style>
    :root{ --bg:#0b0c10;--panel:#121318;--muted:#9aa3b2;--fg:#f3f4f6;--border:#1f2430; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #map{position:absolute;inset:0}
    .panel{
      position:absolute;top:12px;left:12px;z-index:1000;background:var(--panel);
      border:1px solid var(--border);border-radius:12px;padding:12px;min-width:360px;max-width:440px;
      box-shadow:0 8px 28px rgba(0,0,0,.35);overflow:hidden;box-sizing:border-box
    }
    .panel *{box-sizing:border-box}
    .panel .hdr{font-size:12px;color:var(--muted);margin-bottom:6px}
    label{display:block;font-size:12px;color:var(--muted);margin:6px 0 4px}
    input,select,button{
      width:100%;max-width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);
      background:#0f1219;color:var(--fg);appearance:none
    }
    .row{display:grid;grid-template-columns:repeat(12,1fr);gap:10px}
    .col-6{grid-column:span 6}.col-12{grid-column:span 12}
    .btn{cursor:pointer;font-weight:600}.btn:hover{background:#1a1f2b}
    .btn-accent{border-color:#1f3b2f;background:#0f2b22}
    .small{font-size:12px}.muted{color:var(--muted)}
    #msg{min-height:18px}
    .leaflet-top.leaflet-right{margin-right:12px;margin-top:12px}
    .leaflet-top.leaflet-left{margin-left:12px;margin-top:12px}

    /* white tag by default; blue when selected */
    .leaflet-tooltip.pole-tag{
      background:#fff;border:1px solid #e5e7eb;color:#111827;
      box-shadow:0 4px 10px rgba(0,0,0,.12);
      border-radius:8px;padding:4px 6px;font-size:10px;line-height:1.15
    }
    .pole-tag .id{font-weight:700}
    .pole-tag .status{color:#374151}
    .pole-tag .notes{color:#6b7280;font-size:10px;margin-top:2px}
    .leaflet-popup-content .pnote{margin-top:2px;font-size:11px;color:#6b7280}
    .leaflet-tooltip.pole-tag.selected{ background:#2563eb;border-color:#2563eb;color:#fff; }
    .leaflet-tooltip.pole-tag.selected .status{color:#e5efff}
    .leaflet-tooltip.pole-tag.selected .id{color:#fff}

    .hint{font-size:11px;color:var(--muted);margin-top:6px}

    /* === Permit-areas label & control === */
    .permit-area-label{
      font: 600 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", sans-serif;
      padding: 4px 6px;
      background: rgba(255,255,255,0.9);
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.15);
      white-space: nowrap;
    }
    .leaflet-control.permit-areas-control{
      background:#fff;padding:8px 10px;border-radius:6px;box-shadow:0 1px 3px rgba(0,0,0,.2)
    }
    .leaflet-control.permit-areas-control label{display:flex;align-items:center;gap:8px;font-weight:600}
    .leaflet-control.permit-areas-control small{display:block;font-weight:500;opacity:.7;margin-top:4px}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <div class="hdr" id="jobName">Job: —</div>
    <div class="small muted" id="selInfo" style="margin-bottom:8px">Selected poles: 0</div>

    <div class="row">
      <div class="col-12">
        <label>Mode</label>
        <select id="mode">
          <option value="assign">Assign new permits (only poles with no permits)</option>
          <option value="modify">Modify existing permits (status only)</option>
        </select>
      </div>

      <div class="col-12 assign-only">
        <label>Base Permit ID (we append “_SCID”)</label>
        <input id="baseId" placeholder="e.g., BTX02-F36_BRN02-F05_SEG2"/>
      </div>

      <div class="col-6">
        <label>Permit Status</label>
        <select id="status">
          <option>Created - NOT Submitted</option>
          <option>Submitted - Pending</option>
          <option>Approved</option>
          <option>Not Approved - Cannot Attach</option>
          <option>Not Approved - PLA Issues</option>
          <option>Not Approved - MRE Issues</option>
          <option>Not Approved - Other Issues</option>
        </select>
      </div>
      <div class="col-6 assign-only">
        <label>Submitted By</label>
        <input id="by" placeholder="Name"/>
      </div>
      <div class="col-6 assign-only">
        <label>Submitted At</label>
        <input id="date" type="date"/>
      </div>

      <div class="col-6"><label>&nbsp;</label><button id="btnClear" type="button">Clear Selection</button></div>
      <div class="col-6"><label>&nbsp;</label><button id="btnApply" class="btn btn-accent" type="button">Apply to Selected Poles</button></div>

      <div class="col-12"><div id="msg" class="small muted" style="margin-top:2px"></div></div>
      <div class="col-12"><div class="hint">Use the polygon/rectangle tools (top-right) to draw one or more areas. Selected labels turn <b style="color:#2563eb">blue</b>.</div></div>
    </div>
  </div>

  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <!-- === Capture the Leaflet map instance ASAP (must run BEFORE your map.js creates the map) === -->
  <script>
  (function(){

    // --- Wrap L.map once to expose the instance and attach our hook ---
    if (window.L && !window.__L_MAP_WRAPPED__) {
      window.__L_MAP_WRAPPED__ = true;
      const _map = L.map;
      L.map = function(){
        const m = _map.apply(this, arguments);
        window.__leaflet_map__ = m;  // always expose the instance
        attachNotesInjector(m);      // attach when the map is created
        return m;
      };
    }

    // --- If the map already exists (wrapper loaded late), still attach ---
    if (window.__leaflet_map__) attachNotesInjector(window.__leaflet_map__);

    // ================= helper + injector (idempotent) ==================
    function attachNotesInjector(m){
      if (!m || m.__pnote_hooked__) return;
      m.__pnote_hooked__ = true;

      // Inject a tiny style for the notes line (safe to run once)
      const STYLE_ID = 'pnote-style';
      if (!document.getElementById(STYLE_ID)){
        const s = document.createElement('style');
        s.id = STYLE_ID;
        s.textContent = '.leaflet-popup-content .pnote{margin-top:2px;font-size:11px;color:#6b7280}';
        document.head.appendChild(s);
      }

      const jobParam = new URLSearchParams(location.search).get('job') || '';

      function key(job, tag, scid){
        return `${String(job||'').trim()}::${String(tag||'').trim()}::${String(scid||'').trim()}`;
      }

      function readNote(rec){
        if(!rec) return null;
        const c = [
          rec.notes, rec.Notes, rec.permit_notes, rec.PermitNotes, rec.Permit_Notes,
          rec.note, rec.Note, rec.comments, rec.Comments
        ];
        for (const v of c){
          if (typeof v === 'string' && v.trim()) return v.trim();
          if (v && typeof v === 'object'){
            if (Array.isArray(v)){
              for (const it of v){
                if (typeof it === 'string' && it.trim()) return it.trim();
                if (it && typeof it === 'object'){
                  const t = it.text || it.note || it.Notes || it.comment || it.Comment;
                  if (typeof t === 'string' && t.trim()) return t.trim();
                }
              }
            } else {
              const t = v.text || v.note || v.Notes || v.comment || v.Comment;
              if (typeof t === 'string' && t.trim()) return t.trim();
            }
          }
        }
        return null;
      }

      async function buildPermitIndex(){
        if (m.__permit_index__) return m.__permit_index__;
        let list = [];

        // Prefer already-loaded state if present
        const S = window.STATE || {};
        if (Array.isArray(S.permits)) list = S.permits;
        else if (Array.isArray(S.data?.permits)) list = S.data.permits;

        // Otherwise, try common JSON paths
        if (!list.length){
          const candidates = ['permits.json','./permits.json','data/permits.json','./data/permits.json'];
          for (const url of candidates){
            try{
              const r = await fetch(url, {cache:'no-store'});
              if (r.ok){
                const d = await r.json();
                list = Array.isArray(d) ? d : (Array.isArray(d?.permits) ? d.permits : []);
                if (list.length) break;
              }
            }catch(_){}
          }
        }

        const idx = new Map();
        for (const r of list){
          const job  = r.job_name ?? r.jobName ?? r.job ?? '';
          const tag  = r.tag ?? r.Tag ?? r.pole_tag ?? r.PoleTag ?? '';
          const scid = r.SCID ?? r.scid ?? r.pole_scid ?? r.scid_num ?? '';
          if (tag || scid) idx.set(key(job, tag, scid), r);
        }
        m.__permit_index__ = idx;
        return idx;
      }

      function parseScidTag(contentEl){
        const txt = (contentEl.innerText || contentEl.textContent || '').trim();
        // e.g. "SCID 001 - Tag 52883"
        const mm = txt.match(/SCID\s*([A-Za-z0-9._-]+).*?Tag\s*([A-Za-z0-9._-]+)/i);
        if (mm) return { scid: mm[1], tag: mm[2] };
        return null;
      }

      m.on('popupopen', async (ev)=>{
        try{
          const root = ev?.popup?.getElement?.();
          if (!root) return;
          const content = root.querySelector('.leaflet-popup-content');
          if (!content || content.querySelector('.pnote')) return; // already added

          const parsed = parseScidTag(content);
          if (!parsed) return;

          const idx  = await buildPermitIndex();
          const rec  = idx.get(key(jobParam, parsed.tag, parsed.scid));
          const note = readNote(rec);
          if (!note) return;

          const div = document.createElement('div');
          div.className = 'pnote';
          div.textContent = note;  // plain text append under status line
          content.appendChild(div);
        }catch(e){
          console.warn('permit-notes inject failed:', e);
        }
      });
    }

  })();
  </script>


  <!-- shared config + map logic + watcher graphics (unchanged) -->
  <script src="assets/js/config.js?v=api2"></script>
  <script src="assets/js/map.js"></script>
  <script src="assets/js/watch.js"></script>

<!-- === Permit Areas overlay (precise, no-touch per prefix) + TOP-RIGHT pro toggle + Pole Labels cycler === -->
<script>
(function(){
  'use strict';

  /* ================= Tunables (same behavior you approved) ================= */
  const EPS_CLAMP_MIN_M     = 30;
  const EPS_CLAMP_MAX_M     = 160;
  const MAXEDGE_MIN_M       = 60;
  const MAXEDGE_FACTOR      = 1.9;
  const MST_LINE_BUF_F      = 0.35;
  const POINT_BUF_F         = 0.33;
  const BASE_BUFFER_M       = 10;
  const SIMPLIFY_TOL_M      = 3;
  const MORPH_CLOSE_M       = 2;
  const VOR_MARGIN_M        = 600;
  const CLEAR_GAP_M         = 8;
  const RECOVER_F           = 0.45;

  const POLY_STYLE = { color:'#7b61ff', weight:2, opacity:0.95, fillOpacity:0.10, dashArray:'6,4' };

  /* ================= Helpers ================= */
  const degPerMeterLat = 1 / 111320;
  const degTol = SIMPLIFY_TOL_M * degPerMeterLat;
  const getJob = () => new URLSearchParams(location.search).get('job') || '';

  function isLeafletMap(m){
    return !!(m && typeof m.addControl === 'function' && typeof m.addLayer === 'function' &&
              typeof m.getCenter === 'function' && m._leaflet_id != null);
  }
  function mapInstance(){
    if (isLeafletMap(window.__leaflet_map__)) return window.__leaflet_map__;
    for (const k of Object.keys(window)){ try{ const v = window[k]; if (isLeafletMap(v)) return v; }catch(_){} }
    return null;
  }

  const getLat = o => o?.lat ?? o?.latitude ?? o?.Latitude ?? o?.LAT ?? null;
  const getLng = o => o?.lng ?? o?.lon ?? o?.longitude ?? o?.Longitude ?? o?.LON ?? o?.LONG ?? null;
  function readPermitId(r){ return r?.permit_id ?? r?.permitId ?? r?.permit_no ?? r?.permit_number ?? r?.permit ?? r?.Permit ?? r?.id ?? null; }
  function toPrefix(id){ if (!id || typeof id !== 'string') return null; let s=id.trim(); while (/_\d+$/.test(s)) s=s.replace(/_\d+$/,''); return s; }
  async function smartFetch(paths){ for (const p of paths){ try{ const r=await fetch(p,{cache:'no-store'}); if(r.ok) return r.json(); }catch(_){} } return null; }

  function buildPointsFromSTATE(job){
    const S = window.STATE || {};
    const poles   = Array.isArray(S.poles)   ? S.poles   : [];
    const permits = Array.isArray(S.permits) ? S.permits : [];
    const byPole = new Map();
    for (const r of permits){ const k=`${r.job_name}::${r.tag}::${r.SCID}`; if(!byPole.has(k)) byPole.set(k,[]); byPole.get(k).push(r); }
    const pts = [];
    for (const p of poles){
      if (job && String(p.job_name) !== String(job)) continue;
      const lat=+getLat(p), lng=+getLng(p); if(!Number.isFinite(lat)||!Number.isFinite(lng)) continue;
      const rel = byPole.get(`${p.job_name}::${p.tag}::${p.SCID}`) || [];
      for (const r of rel){ const id=readPermitId(r); const prefix=toPrefix(String(id||'')); if(prefix) pts.push({lat,lng,prefix}); }
    }
    return pts;
  }
  async function buildPointsFromFiles(job){
    const base = ["data","./data","."];
    const polesP   = base.map(p=>`${p}/poles.json`).concat(["poles.json","./poles.json"]);
    const permitsP = base.map(p=>`${p}/permits.json`).concat(["permits.json","./permits.json"]);
    const [poles,permits] = await Promise.all([smartFetch(polesP),smartFetch(permitsP)]);
    const byPole = new Map();
    if (Array.isArray(permits)) for (const r of permits){ const k=`${r.job_name}::${r.tag}::${r.SCID}`; if(!byPole.has(k)) byPole.set(k,[]); byPole.get(k).push(r); }
    const pts=[];
    if (Array.isArray(poles)) for (const p of poles){
      if (job && String(p.job_name) !== String(job)) continue;
      const lat=+getLat(p), lng=+getLng(p); if(!Number.isFinite(lat)||!Number.isFinite(lng)) continue;
      const rel = byPole.get(`${p.job_name}::${p.tag}::${p.SCID}`) || [];
      for (const r of rel){ const id=readPermitId(r); const prefix=toPrefix(String(id||'')); if(prefix) pts.push({lat,lng,prefix}); }
    }
    return pts;
  }

  // Adaptive eps from nearest-neighbor stats
  function percentile(sorted,p){ if(!sorted.length) return 0; const i=(sorted.length-1)*p; const lo=Math.floor(i), hi=Math.ceil(i); return lo===hi?sorted[lo]:sorted[lo]+(sorted[hi]-sorted[lo])*(i-lo); }
  function nearestNeighborMeters(coords){
    const out=[]; for(let i=0;i<coords.length;i++){ let best=Infinity;
      for(let j=0;j<coords.length;j++){ if(i===j) continue; const d=turf.distance(coords[i],coords[j],{units:'meters'}); if(d<best) best=d; }
      if(Number.isFinite(best)) out.push(best);
    }
    return out.sort((a,b)=>a-b);
  }
  function adaptiveEpsMeters(coords){
    if (coords.length<2) return 50;
    const nnd = nearestNeighborMeters(coords);
    const p50=percentile(nnd,0.50), p75=percentile(nnd,0.75);
    let eps = Math.max(p75*1.5, p50*1.7);
    return Math.min(Math.max(eps, EPS_CLAMP_MIN_M), EPS_CLAMP_MAX_M);
  }
  // Minimum Spanning Tree (Prim)
  function mstEdges(coords){
    const n = coords.length; if (n<=1) return [];
    const inMST=new Array(n).fill(false), dist=new Array(n).fill(Infinity), parent=new Array(n).fill(-1);
    dist[0]=0;
    for(let k=0;k<n;k++){
      let u=-1, best=Infinity; for(let i=0;i<n;i++){ if(!inMST[i] && dist[i]<best){ best=dist[i]; u=i; } }
      if(u===-1) break; inMST[u]=true;
      for(let v=0; v<n; v++){
        if(inMST[v]) continue;
        const d=turf.distance(coords[u], coords[v], {units:'meters'});
        if(d<dist[v]){ dist[v]=d; parent[v]=u; }
      }
    }
    const edges=[]; for(let v=1; v<n; v++){ if(parent[v]!==-1) edges.push([coords[v], coords[parent[v]]]); }
    return edges;
  }

  // Pill CSS (black pill + red bold text + blink) and control/labels CSS
  function ensureUIStyles(){
    if (document.getElementById('permit-pill-css')) return;
    const s = document.createElement('style'); s.id='permit-pill-css';
    s.textContent = `
      /* Black pill for area label */
      .permit-pill{background:#000;color:#e11d48;border:1px solid rgba(255,255,255,.28);
        padding:4px 8px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,.35);
        font-weight:800;white-space:nowrap;}
      @keyframes permitBlink{0%{opacity:.60} 50%{opacity:1} 100%{opacity:.60}}
      .permit-blink{animation:permitBlink 1.2s ease-in-out infinite;}

      /* Professional control card */
      .overlay-ctl{background:#fff;padding:10px 12px;border-radius:10px;box-shadow:0 1px 3px rgba(0,0,0,.2);min-width:180px}
      .overlay-ctl .row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin:6px 0}
      .overlay-ctl .label{font:600 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial;color:#6b7280}
      .overlay-ctl .small{font:500 11px/1.2 system-ui;color:#9ca3af}

      /* Switch */
      .switch{position:relative;display:inline-block;width:42px;height:24px}
      .switch input{display:none}
      .slider{position:absolute;inset:0;background:#e5e7eb;border-radius:9999px;transition:background .2s ease;box-shadow:inset 0 0 0 1px rgba(0,0,0,.06)}
      .slider:before{content:"";position:absolute;width:18px;height:18px;left:3px;top:3px;background:#fff;border-radius:50%;transition:transform .2s ease;box-shadow:0 1px 2px rgba(0,0,0,.25)}
      .switch input:checked + .slider{background:#2563eb}
      .switch input:checked + .slider:before{transform:translateX(18px)}

      /* Button */
      .ctl-btn{appearance:none;border:1px solid #e5e7eb;background:#f9fafb;border-radius:8px;padding:6px 10px;font:600 12px system-ui;color:#111827;cursor:pointer}
      .ctl-btn:hover{background:#eef2ff;border-color:#c7d2fe}

      /* SCID-only overlay chip */
      .scid-chip{background:#111827;color:#f9fafb;border:1px solid rgba(255,255,255,.25);
        padding:2px 6px;border-radius:6px;font:700 10px/1.1 system-ui, -apple-system, Segoe UI, Roboto, Arial;white-space:nowrap}

      /* Hide your existing full pole labels when cycling */
      #map.labels-scid .leaflet-tooltip.pole-tag:not(.scid-only){ display:none !important; }
      #map.labels-none .leaflet-tooltip.pole-tag{ display:none !important; }
    `;
    document.head.appendChild(s);
  }

  // Build ONE tight polygon for a whole prefix (no-touch via Voronoi later)
  function prefixPolygon(feats){
    const coords = feats.map(f=>f.geometry.coordinates);
    const eps = adaptiveEpsMeters(coords);
    const subFC = turf.featureCollection(feats);
    const maxEdge = Math.max(MAXEDGE_MIN_M, eps * MAXEDGE_FACTOR);

    // concave hull (fallback convex)
    let poly = (feats.length >= 3) ? turf.concave(subFC, {maxEdge, units:'meters'}) : null;
    if (!poly) poly = (feats.length >= 3) ? turf.convex(subFC) : null;

    // MST corridor for linear runs
    const edges = mstEdges(coords);
    let corridor = null;
    const lineW = Math.max(5, eps * MST_LINE_BUF_F);
    for (const e of edges){
      const ls = turf.lineString(e);
      const b  = turf.buffer(ls, lineW, {units:'meters'});
      corridor = corridor ? (turf.union(corridor, b) || corridor) : b;
    }

    // per-point disks
    let pbuf = null;
    const rPoint = Math.max(5, eps * POINT_BUF_F);
    for (const f of feats){
      const b = turf.buffer(f, rPoint, {units:'meters'});
      pbuf = pbuf ? (turf.union(pbuf, b) || pbuf) : b;
    }

    // union + polish
    let merged = null;
    for (const g of [poly, corridor, pbuf]){ if(!g) continue; merged = merged ? (turf.union(merged, g) || merged) : g; }
    if (!merged) return { geom:null, eps };

    try { merged = turf.buffer(merged, MORPH_CLOSE_M, {units:'meters'}); merged = turf.buffer(merged, -MORPH_CLOSE_M, {units:'meters'}); } catch(_){}
    try { merged = turf.buffer(merged, BASE_BUFFER_M, {units:'meters'}); } catch(_){}
    try { merged = turf.simplify(merged, {tolerance: degTol, highQuality:false}); } catch(_){}

    return { geom: merged, eps };
  }

  // Voronoi helpers
  const coordKey = (lng,lat) => `${lng.toFixed(6)},${lat.toFixed(6)}`;
  function buildVoronoiMap(allPoints){
    const feats = allPoints.map(p => turf.point([p.lng, p.lat], { key: coordKey(p.lng,p.lat) }));
    if (!feats.length) return new Map();
    const fc = turf.featureCollection(feats);
    const bbox = turf.bbox(turf.buffer(fc, VOR_MARGIN_M, {units:'meters'}));
    const vor  = turf.voronoi(fc, { bbox });
    const map = new Map();
    if (vor && Array.isArray(vor.features)){
      for (const cell of vor.features){
        if (!cell) continue;
        for (const f of feats){
          const k = f.properties.key;
          if (map.has(k)) continue;
          try { if (turf.booleanPointInPolygon(f, cell)) { map.set(k, cell); } } catch(_){}
        }
      }
    }
    return map;
  }

  // Build final areas layer (single, precise, non-touch per prefix)
  function buildAreasLayer(points){
    const byPrefix = new Map();
    for (const pt of points){ if(!pt||!pt.prefix) continue; if(!byPrefix.has(pt.prefix)) byPrefix.set(pt.prefix, []); byPrefix.get(pt.prefix).push(pt); }
    if (!byPrefix.size) return L.layerGroup();

    const vorMap = buildVoronoiMap(points);
    const layer = L.layerGroup();

    byPrefix.forEach((pts, prefix) => {
      const feats = pts.map(p=>turf.point([p.lng,p.lat], p));
      const { geom:rawGeom } = prefixPolygon(feats);
      if (!rawGeom) return;

      // union of THIS prefix's Voronoi cells
      let ownCells = null;
      for (const p of pts){ const cell = vorMap.get(coordKey(p.lng,p.lat)); if (!cell) continue; ownCells = ownCells ? (turf.union(ownCells, cell) || ownCells) : cell; }
      if (!ownCells) return;

      // constrain and erode for gap
      let constrained = null; try { constrained = turf.intersect(rawGeom, ownCells) || ownCells; } catch(_){ constrained = ownCells; }
      let safe = constrained; try { safe = turf.buffer(constrained, -CLEAR_GAP_M, {units:'meters'}); safe = turf.intersect(safe, ownCells) || safe; } catch(_){}

      // recover poles inside *eroded* cells only
      const erodedCells = (() => { try { return turf.buffer(ownCells, -CLEAR_GAP_M, {units:'meters'}); } catch(_){ return ownCells; }})();
      const recoverR = Math.max(2, CLEAR_GAP_M * RECOVER_F);
      for (const p of pts){
        const pt = turf.point([p.lng,p.lat]);
        try{
          if (!turf.booleanPointInPolygon(pt, safe)) {
            const disk = turf.buffer(pt, recoverR, {units:'meters'});
            const clipped = turf.intersect(disk, erodedCells);
            if (clipped) safe = turf.union(safe, clipped) || safe;
          }
        }catch(_){}
      }

      const gj = L.geoJSON(safe, { style: POLY_STYLE, interactive:false });
      layer.addLayer(gj);

      // label inside polygon
      const pin = turf.pointOnFeature(safe).geometry.coordinates;
      const html = `<div class="permit-pill permit-blink"><span>${prefix}</span></div>`;
      const lbl  = L.marker([pin[1], pin[0]], { icon: L.divIcon({ className:'', html, iconAnchor:[0,0] }), interactive:false, keyboard:false });
      layer.addLayer(lbl);
    });

    return layer;
  }

  /* ================= SCID-only labels overlay (for cycling) ================= */
  async function gatherPoles(){
    const job = getJob();
    const S = window.STATE || {};
    if (Array.isArray(S.poles) && S.poles.length){
      return S.poles.filter(p => !job || String(p.job_name) === String(job));
    }
    const base = ["data","./data","."];
    const polesP = base.map(p=>`${p}/poles.json`).concat(["poles.json","./poles.json"]);
    const all = await smartFetch(polesP) || [];
    return all.filter(p => !job || String(p.job_name) === String(job));
  }

  function buildScidLayer(poles){
    const g = L.layerGroup();
    for (const p of poles){
      const lat = +getLat(p), lng = +getLng(p);
      const scid = (p && p.SCID != null) ? String(p.SCID) : null;
      if (!Number.isFinite(lat) || !Number.isFinite(lng) || !scid) continue;

      const tt = L.tooltip({
        permanent: true,
        direction: 'right',
        offset: [8, 0],
        className: 'pole-tag scid-only'  // <- same style as your normal labels, but marked scid-only
      })
      .setContent(`SCID ${scid}`)
      .setLatLng([lat, lng]);

      g.addLayer(tt);
    }
    return g;
  }

  let labelMode = 'normal'; // normal → scid → none
  async function setLabelMode(mode){
    labelMode = mode;
    const mapDiv = document.getElementById('map');
    if (!mapDiv) return;
    mapDiv.classList.remove('labels-scid','labels-none');
    const map = mapInstance(); if (!isLeafletMap(map)) return;

    // ensure layer exists if needed
    if (mode === 'scid') {
      if (!window.__scidLabelsLayer) {
        const poles = await gatherPoles();
        window.__scidLabelsLayer = buildScidLayer(poles);
      }
      if (!map.hasLayer(window.__scidLabelsLayer)) window.__scidLabelsLayer.addTo(map);
      mapDiv.classList.add('labels-scid');
    } else {
      if (window.__scidLabelsLayer && map.hasLayer(window.__scidLabelsLayer)) map.removeLayer(window.__scidLabelsLayer);
      if (mode === 'none') mapDiv.classList.add('labels-none');
    }

    // update button text
    const btn = document.getElementById('labelCycleBtn');
    if (btn) btn.textContent = `Pole Labels: ${mode === 'normal' ? 'Normal' : mode === 'scid' ? 'SCID only' : 'None'}`;
  }
  function cycleLabelMode(){
    if (labelMode === 'normal') setLabelMode('scid');
    else if (labelMode === 'scid') setLabelMode('none');
    else setLabelMode('normal');
  }
  async function rebuildScidLayer(){
    // rebuild from fresh data (e.g., after data:loaded)
    const map = mapInstance(); if (!isLeafletMap(map)) return;
    if (window.__scidLabelsLayer && map.hasLayer(window.__scidLabelsLayer)) map.removeLayer(window.__scidLabelsLayer);
    window.__scidLabelsLayer = null;
    if (labelMode === 'scid') await setLabelMode('scid');
  }

  /* ================= Build + Toggle areas ================= */
  // === Permit notes → label appender (non-invasive) ==========================
  function readNotes(r){
    return r?.notes ?? r?.Notes ?? r?.permit_notes ?? r?.PermitNotes ?? r?.Permit_Notes ?? r?.note ?? r?.Note ?? null;
  }
  function buildPermitIndex(){
    const S = window.STATE || {};
    const list = Array.isArray(S.permits) ? S.permits : [];
    const m = new Map();
    for (const r of list){
      const key = `${r?.job_name ?? r?.jobName ?? ""}::${r?.tag ?? r?.Tag ?? ""}::${r?.SCID ?? r?.scid ?? ""}`;
      if (key.includes("::")) m.set(key, r);
    }
    return m;
  }
  function applyNotesToLabels(){
    const job = (new URLSearchParams(location.search).get('job') || "").toString();
    const idx = buildPermitIndex();
    const labels = document.querySelectorAll('.leaflet-tooltip.pole-tag:not(.scid-only)');
    labels.forEach(el=>{
      // Labels look like: "SCID 001 - Tag 52883"
      const m = (el.textContent || "").match(/SCID\s*(\d+).*?Tag\s*([A-Za-z0-9_-]+)/i);
      if (!m) return;
      const scid = m[1], tag = m[2];
      const rec  = idx.get(`${job}::${tag}::${scid}`);
      const note = readNotes(rec);
      if (!note) return;

      let notesDiv = el.querySelector('.notes');
      if (!notesDiv){
        notesDiv = document.createElement('div');
        notesDiv.className = 'notes';
        el.appendChild(notesDiv);
      }
      notesDiv.textContent = String(note); // simple safe text insert
    });
  }

  async function gatherPoints(){
    const S = window.STATE || {};
    const hasSTATE = Array.isArray(S.poles) && Array.isArray(S.permits) && (S.poles.length || S.permits.length);
    if (hasSTATE) return buildPointsFromSTATE(getJob());
    return buildPointsFromFiles(getJob());
  }
  async function rebuildAreas(){
    const map = mapInstance();
    if (!isLeafletMap(map) || !window.L) return;
    if (window.__permitAreasLayer && map.hasLayer(window.__permitAreasLayer)) map.removeLayer(window.__permitAreasLayer);
    const points = await gatherPoints();
    const layer  = buildAreasLayer(points);
    window.__permitAreasLayer = layer;
    const toggle = document.getElementById('permitAreasSwitch');
    const isOn = !toggle || toggle.checked;
    if (isOn && layer) layer.addTo(map);
  }

  /* ================= Control (top-right): Pro switch + labels cycler ================= */
  const OverlayControl = L.Control.extend({
    onAdd: function(){
      const div = L.DomUtil.create('div', 'overlay-ctl');
      div.innerHTML = `
        <div class="row">
          <span class="label">Permit Areas</span>
          <label class="switch" title="Toggle permit areas">
            <input type="checkbox" id="permitAreasSwitch" checked />
            <span class="slider"></span>
          </label>
        </div>
        <div class="row">
          <button id="labelCycleBtn" class="ctl-btn" title="Cycle pole labels: Normal → SCID only → None">Pole Labels: Normal</button>
        </div>
        <div class="small" style="margin-top:2px">Single, precise, non-touch areas per prefix</div>
      `;
      return div;
    }
  });

  function wireControl(map){
    // Areas switch
    const sw = document.getElementById('permitAreasSwitch');
    if (sw){
      sw.addEventListener('change', ()=>{
        const layer = window.__permitAreasLayer;
        if (!layer) return;
        if (sw.checked) { if (!map.hasLayer(layer)) layer.addTo(map); }
        else { if (map.hasLayer(layer)) map.removeLayer(layer); }
      });
    }
    // Labels cycler
    const btn = document.getElementById('labelCycleBtn');
    if (btn) btn.addEventListener('click', cycleLabelMode);
  }

  /* ================= Boot + hot-swap ================= */
  async function boot(){
    ensureUIStyles();
    const map = mapInstance();
    if (!isLeafletMap(map) || !window.L) { setTimeout(boot, 200); return; }

    // Control (top-right)
    const ctl = new OverlayControl({ position: 'topright' });
    map.addControl(ctl);

    // Wire events once the DOM is ready
    const wait = () => {
      if (document.getElementById('permitAreasSwitch') && document.getElementById('labelCycleBtn')) {
        wireControl(map);
        rebuildAreas();
        setLabelMode('normal'); // initial state
      } else setTimeout(wait, 100);
    };
    wait();

    // Hot refresh
    window.addEventListener('data:loaded',   ()=>{ rebuildAreas(); rebuildScidLayer(); });
    window.addEventListener('poles:loaded',  ()=>{ rebuildAreas(); rebuildScidLayer(); });
    window.addEventListener('permits:loaded',()=>{ rebuildAreas(); rebuildScidLayer(); });
    window.addEventListener('state:updated', ()=>{ rebuildAreas(); rebuildScidLayer(); });

    ['data:loaded','poles:loaded','permits:loaded','state:updated'].forEach(ev=>{
      window.addEventListener(ev, ()=> setTimeout(applyNotesToLabels, 0));
    });

    // first pass shortly after the controls/labels appear
    setTimeout(applyNotesToLabels, 300);

    // Manual hooks if needed
    window.refreshPermitAreas = rebuildAreas;
    window.refreshScidLabels  = rebuildScidLayer;
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();

})();
</script>
