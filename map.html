<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Map Selection</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />

  <style>
    :root{ --bg:#0b0c10;--panel:#121318;--muted:#9aa3b2;--fg:#f3f4f6;--border:#1f2430; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #map{position:absolute;inset:0}
    .panel{
      position:absolute;top:12px;left:12px;z-index:1000;background:var(--panel);
      border:1px solid var(--border);border-radius:12px;padding:12px;min-width:360px;max-width:440px;
      box-shadow:0 8px 28px rgba(0,0,0,.35);overflow:hidden;box-sizing:border-box
    }
    .panel *{box-sizing:border-box}
    .panel .hdr{font-size:12px;color:var(--muted);margin-bottom:6px}
    label{display:block;font-size:12px;color:var(--muted);margin:6px 0 4px}
    input,select,button{
      width:100%;max-width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);
      background:#0f1219;color:var(--fg);appearance:none
    }
    .row{display:grid;grid-template-columns:repeat(12,1fr);gap:10px}
    .col-6{grid-column:span 6}.col-12{grid-column:span 12}
    .btn{cursor:pointer;font-weight:600}.btn:hover{background:#1a1f2b}
    .btn-accent{border-color:#1f3b2f;background:#0f2b22}
    .small{font-size:12px}.muted{color:var(--muted)}
    #msg{min-height:18px}
    .leaflet-top.leaflet-right{margin-right:12px;margin-top:12px}
    .leaflet-top.leaflet-left{margin-left:12px;margin-top:12px}

    /* white tag by default; blue when selected */
    .leaflet-tooltip.pole-tag{
      background:#fff;border:1px solid #e5e7eb;color:#111827;
      box-shadow:0 4px 10px rgba(0,0,0,.12);
      border-radius:8px;padding:4px 6px;font-size:10px;line-height:1.15
    }
    .pole-tag .id{font-weight:700}
    .pole-tag .status{color:#374151}
    .leaflet-tooltip.pole-tag.selected{ background:#2563eb;border-color:#2563eb;color:#fff; }
    .leaflet-tooltip.pole-tag.selected .status{color:#e5efff}
    .leaflet-tooltip.pole-tag.selected .id{color:#fff}

    .hint{font-size:11px;color:var(--muted);margin-top:6px}

    /* === Permit-areas label & control === */
    .permit-area-label{
      font: 600 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", sans-serif;
      padding: 4px 6px;
      background: rgba(255,255,255,0.9);
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.15);
      white-space: nowrap;
    }
    .leaflet-control.permit-areas-control{
      background:#fff;padding:8px 10px;border-radius:6px;box-shadow:0 1px 3px rgba(0,0,0,.2)
    }
    .leaflet-control.permit-areas-control label{display:flex;align-items:center;gap:8px;font-weight:600}
    .leaflet-control.permit-areas-control small{display:block;font-weight:500;opacity:.7;margin-top:4px}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <div class="hdr" id="jobName">Job: —</div>
    <div class="small muted" id="selInfo" style="margin-bottom:8px">Selected poles: 0</div>

    <div class="row">
      <div class="col-12">
        <label>Mode</label>
        <select id="mode">
          <option value="assign">Assign new permits (only poles with no permits)</option>
          <option value="modify">Modify existing permits (status only)</option>
        </select>
      </div>

      <div class="col-12 assign-only">
        <label>Base Permit ID (we append “_SCID”)</label>
        <input id="baseId" placeholder="e.g., BTX02-F36_BRN02-F05_SEG2"/>
      </div>

      <div class="col-6">
        <label>Permit Status</label>
        <select id="status">
          <option>Created - NOT Submitted</option>
          <option>Submitted - Pending</option>
          <option>Approved</option>
          <option>Not Approved - Cannot Attach</option>
          <option>Not Approved - PLA Issues</option>
          <option>Not Approved - MRE Issues</option>
          <option>Not Approved - Other Issues</option>
        </select>
      </div>
      <div class="col-6 assign-only">
        <label>Submitted By</label>
        <input id="by" placeholder="Name"/>
      </div>
      <div class="col-6 assign-only">
        <label>Submitted At</label>
        <input id="date" type="date"/>
      </div>

      <div class="col-6"><label>&nbsp;</label><button id="btnClear" type="button">Clear Selection</button></div>
      <div class="col-6"><label>&nbsp;</label><button id="btnApply" class="btn btn-accent" type="button">Apply to Selected Poles</button></div>

      <div class="col-12"><div id="msg" class="small muted" style="margin-top:2px"></div></div>
      <div class="col-12"><div class="hint">Use the polygon/rectangle tools (top-right) to draw one or more areas. Selected labels turn <b style="color:#2563eb">blue</b>.</div></div>
    </div>
  </div>

  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <!-- === Capture the Leaflet map instance ASAP (must run BEFORE your map.js creates the map) === -->
  <script>
  (function(){
    if (window.L && !window.__L_MAP_WRAPPED__) {
      window.__L_MAP_WRAPPED__ = true;
      const _map = L.map;
      L.map = function(){
        const m = _map.apply(this, arguments);
        window.__leaflet_map__ = m;  // always expose the instance
        return m;
      };
    }
  })();
  </script>

  <!-- shared config + map logic + watcher graphics (unchanged) -->
  <script src="assets/js/config.js?v=api2"></script>
  <script src="assets/js/map.js"></script>
  <script src="assets/js/watch.js"></script>

<!-- === Permit Areas overlay (adaptive clusters + guaranteed coverage; toggle ON) === -->
<script>
(function(){
  'use strict';

  // ---------- Tunables ----------
  const DBSCAN_MIN_POINTS   = 1;    // allow singletons to form tiny clusters
  const EPS_CLAMP_MIN_M     = 35;   // lower clamp for adaptive eps
  const EPS_CLAMP_MAX_M     = 170;  // upper clamp for adaptive eps
  const MAXEDGE_MIN_M       = 70;   // lower clamp for concave "tightness"
  const MAXEDGE_FACTOR      = 2.2;  // concave maxEdge ~= eps * factor
  const OUTLIER_BUFFER_F    = 0.35; // outlier fix: buffer radius = eps * this
  const BASE_BUFFER_M       = 22;   // general breathing room for polygons
  const SIMPLIFY_TOL_M      = 3;    // small smoothing
  const POLY_STYLE = { color:'#7b61ff', weight:2, opacity:0.95, fillOpacity:0.10, dashArray:'6,4' };

  // ---------- Helpers ----------
  const degPerMeterLat = 1 / 111320;
  const degPerMeterLngAt = (lat) => {
    const m = 111320 * Math.cos((lat||0) * Math.PI/180);
    return m > 0 ? 1 / m : 1 / 111320;
  };
  const degTol = SIMPLIFY_TOL_M * degPerMeterLat;
  const getJob = () => new URLSearchParams(location.search).get('job') || '';

  function isLeafletMap(m){
    return !!(m && typeof m.addControl === 'function' && typeof m.addLayer === 'function' &&
              typeof m.getCenter === 'function' && m._leaflet_id != null);
  }
  function mapInstance(){
    if (isLeafletMap(window.__leaflet_map__)) return window.__leaflet_map__;
    for (const k of Object.keys(window)){ try{ const v = window[k]; if (isLeafletMap(v)) return v; }catch(_){} }
    return null;
  }

  const getLat = o => o?.lat ?? o?.latitude ?? o?.Latitude ?? o?.LAT ?? null;
  const getLng = o => o?.lng ?? o?.lon ?? o?.longitude ?? o?.Longitude ?? o?.LON ?? o?.LONG ?? null;

  function readPermitId(r){
    return r?.permit_id ?? r?.permitId ?? r?.permit_no ?? r?.permit_number ?? r?.permit ?? r?.Permit ?? r?.id ?? null;
  }

  // Trim ALL trailing "_<digits>" segments so "..._028_12345" -> "...", e.g., "..._SEG4"
  function toPrefix(id){
    if (!id || typeof id !== 'string') return null;
    let s = id.trim();
    while (/_\d+$/.test(s)) s = s.replace(/_\d+$/, '');
    return s;
  }

  async function smartFetch(paths){
    for (const p of paths) { try { const r = await fetch(p, { cache:'no-store' }); if (r.ok) return r.json(); } catch(_) {} }
    return null;
  }

  function buildPointsFromSTATE(job){
    const S = window.STATE || {};
    const poles   = Array.isArray(S.poles)   ? S.poles   : [];
    const permits = Array.isArray(S.permits) ? S.permits : [];

    const byPole = new Map();
    for (const r of permits){
      const k = `${r.job_name}::${r.tag}::${r.SCID}`;
      if (!byPole.has(k)) byPole.set(k, []);
      byPole.get(k).push(r);
    }

    const pts = [];
    for (const p of poles){
      if (job && String(p.job_name) !== String(job)) continue;
      const lat = +getLat(p), lng = +getLng(p);
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;

      const related = byPole.get(`${p.job_name}::${p.tag}::${p.SCID}`) || [];
      for (const r of related){
        const id = readPermitId(r); const prefix = toPrefix(String(id||""));
        if (prefix) pts.push({ lat, lng, prefix });
      }
    }
    return pts;
  }

  async function buildPointsFromFiles(job){
    const basePaths = ["data", "./data", "."];
    const polePaths   = basePaths.map(p => `${p}/poles.json`).concat(["poles.json","./poles.json"]);
    const permitPaths = basePaths.map(p => `${p}/permits.json`).concat(["permits.json","./permits.json"]);
    const [poles, permits] = await Promise.all([ smartFetch(polePaths), smartFetch(permitPaths) ]);

    const pts = [];
    const byPole = new Map();
    if (Array.isArray(permits)) {
      for (const r of permits){
        const k = `${r.job_name}::${r.tag}::${r.SCID}`;
        if (!byPole.has(k)) byPole.set(k, []);
        byPole.get(k).push(r);
      }
    }
    if (Array.isArray(poles)) {
      for (const p of poles){
        if (job && String(p.job_name) !== String(job)) continue;
        const lat = +getLat(p), lng = +getLng(p);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
        const related = byPole.get(`${p.job_name}::${p.tag}::${p.SCID}`) || [];
        for (const r of related){
          const id = readPermitId(r); const prefix = toPrefix(String(id||""));
          if (prefix) pts.push({ lat, lng, prefix });
        }
      }
    }
    return pts;
  }

  // --- Adaptive neighborhood radius (eps) per prefix ---
  function percentile(sorted, p){ if (!sorted.length) return 0; const i = (sorted.length-1)*p; const lo = Math.floor(i), hi = Math.ceil(i); if (lo===hi) return sorted[lo]; return sorted[lo] + (sorted[hi]-sorted[lo])*(i-lo); }
  function nearestNeighborDistancesMeters(coords){
    // coords: [[lng,lat], ...]
    const out = [];
    for (let i=0;i<coords.length;i++){
      let best = Infinity;
      for (let j=0;j<coords.length;j++){
        if (i===j) continue;
        const d = turf.distance(coords[i], coords[j], {units:'meters'});
        if (d < best) best = d;
      }
      if (Number.isFinite(best)) out.push(best);
    }
    return out.sort((a,b)=>a-b);
  }
  function adaptiveEpsMeters(coords){
    if (coords.length < 2) return 50;
    const nnd = nearestNeighborDistancesMeters(coords);
    const p50 = percentile(nnd, 0.50);
    const p75 = percentile(nnd, 0.75);
    // slightly liberal to keep sequential poles together but not fuse distant runs
    let eps = Math.max(p75*1.6, p50*1.8);
    eps = Math.min(Math.max(eps, EPS_CLAMP_MIN_M), EPS_CLAMP_MAX_M);
    return eps;
  }

  function buildAreasLayer(points){
    // Group by prefix first
    const groups = new Map();
    for (const pt of points){
      if (!pt || !pt.prefix) continue;
      if (!groups.has(pt.prefix)) groups.set(pt.prefix, []);
      groups.get(pt.prefix).push(pt);
    }

    const layer = L.layerGroup();

    groups.forEach((pts, prefix) => {
      if (pts.length < 2) return;

      // Prepare FeatureCollection
      const features = pts.map(p => turf.point([p.lng, p.lat], p));
      const fc = turf.featureCollection(features);

      // Adaptive DBSCAN
      const coords = features.map(f => f.geometry.coordinates);
      const eps    = adaptiveEpsMeters(coords);
      const clustered = turf.clustersDbscan(fc, eps, { units:'meters', minPoints: DBSCAN_MIN_POINTS });

      // Gather clusters (ignore "noise" concept since minPoints=1)
      const clusters = new Map();
      for (const f of clustered.features){
        const cid = f.properties.cluster ?? 0;
        if (!clusters.has(cid)) clusters.set(cid, []);
        clusters.get(cid).push(f);
      }

      clusters.forEach((feats) => {
        if (!feats || feats.length < 2) return;

        const subFC = turf.featureCollection(feats);
        // Concave, fallback to convex
        const maxEdge = Math.max(MAXEDGE_MIN_M, eps * MAXEDGE_FACTOR);
        let poly = (feats.length >= 3) ? turf.concave(subFC, { maxEdge, units:'meters' }) : null;
        if (!poly) poly = (feats.length >= 3) ? turf.convex(subFC) : null;

        // Outlier guarantee: ensure every point is inside; if not, union small buffers
        const checkPoints = feats.map(f => f.geometry.coordinates);
        let needsUnion = false;
        if (poly){
          for (const c of checkPoints){
            if (!turf.booleanPointInPolygon(turf.point(c), poly)) { needsUnion = true; break; }
          }
        } else {
          needsUnion = true;
        }

        if (needsUnion){
          // build a union of small disks around all points, radius relative to eps
          const r = Math.max(12, eps * OUTLIER_BUFFER_F);
          let unionGeom = null;
          for (const f of feats){
            const b = turf.buffer(f, r, {units:'meters'});
            unionGeom = unionGeom ? (turf.union(unionGeom, b) || unionGeom) : b;
          }
          poly = poly ? (turf.union(poly, unionGeom) || unionGeom) : unionGeom;
        }

        // General breathing room + smoothing
        try { poly = turf.buffer(poly, BASE_BUFFER_M, { units:'meters' }); } catch(_) {}
        try { poly = turf.simplify(poly, { tolerance: degTol, highQuality:false }); } catch(_) {}

        // Draw polygon
        const gj = L.geoJSON(poly, { style: POLY_STYLE, interactive:false });
        layer.addLayer(gj);

        // Red, bold label chip (high contrast)
        const ctr = turf.centerOfMass(poly).geometry.coordinates;
        const labelHTML = `<div style="
            background:#ef4444;color:#fff;font-weight:800;font-size:12px;
            padding:4px 8px;border-radius:6px;border:1px solid rgba(0,0,0,.25);
            box-shadow:0 2px 6px rgba(0,0,0,.35);
          ">${prefix}</div>`;
        const label = L.marker([ctr[1], ctr[0]], {
          icon: L.divIcon({ className:'', html: labelHTML, iconAnchor:[0,0] }),
          interactive:false, keyboard:false
        });
        layer.addLayer(label);
      });
    });

    return layer;
  }

  const PermitAreasControl = L.Control.extend({
    onAdd: function(){
      const div = L.DomUtil.create('div', 'leaflet-control permit-areas-control');
      div.innerHTML = `
        <label title="Show polygons around poles that share the same permit prefix">
          <input type="checkbox" id="permitAreasToggle" checked />
          Permit Areas
        </label>
        <small>Adaptive concave polygons; guarantees full coverage</small>
      `;
      return div;
    }
  });

  async function gatherPoints(){
    const S = window.STATE || {};
    const hasSTATE = Array.isArray(S.poles) && Array.isArray(S.permits) && (S.poles.length || S.permits.length);
    return hasSTATE ? buildPointsFromSTATE(getJob()) : buildPointsFromFiles(getJob());
  }

  function wireToggle(map){
    const t = document.getElementById('permitAreasToggle');
    if (!t) return;
    t.addEventListener('change', ()=>{
      const layer = window.__permitAreasLayer;
      if (!layer) return;
      if (t.checked) { if (!map.hasLayer(layer)) layer.addTo(map); }
      else { if (map.hasLayer(layer)) map.removeLayer(layer); }
    });
  }

  async function rebuild(){
    const map = mapInstance();
    if (!isLeafletMap(map) || !window.L) return;

    if (window.__permitAreasLayer && map.hasLayer(window.__permitAreasLayer)) {
      map.removeLayer(window.__permitAreasLayer);
    }

    const points = await gatherPoints();
    const layer  = buildAreasLayer(points);
    window.__permitAreasLayer = layer;

    const toggle = document.getElementById('permitAreasToggle');
    if (!toggle || toggle.checked) { if (layer) layer.addTo(map); }
  }

  function boot(){
    const map = mapInstance();
    if (!isLeafletMap(map) || !window.L) { setTimeout(boot, 200); return; }

    const ctrl = new PermitAreasControl({ position: 'topleft' });
    map.addControl(ctrl);

    const waitToggle = () => {
      if (document.getElementById('permitAreasToggle')) { wireToggle(map); rebuild(); }
      else setTimeout(waitToggle, 100);
    };
    waitToggle();

    // Hot-swap refresh hooks
    window.addEventListener('data:loaded',   rebuild);
    window.addEventListener('poles:loaded',  rebuild);
    window.addEventListener('permits:loaded',rebuild);
    window.addEventListener('state:updated', rebuild);

    window.refreshPermitAreas = rebuild; // manual hook if needed
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();
})();
</script>
