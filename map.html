<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Map Selection</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />

  <style>
    :root{ --bg:#0b0c10;--panel:#121318;--muted:#9aa3b2;--fg:#f3f4f6;--border:#1f2430; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #map{position:absolute;inset:0}
    .panel{
      position:absolute;top:12px;left:12px;z-index:1000;background:var(--panel);
      border:1px solid var(--border);border-radius:12px;padding:12px;min-width:360px;max-width:440px;
      box-shadow:0 8px 28px rgba(0,0,0,.35);overflow:hidden;box-sizing:border-box
    }
    .panel *{box-sizing:border-box}
    .panel .hdr{font-size:12px;color:var(--muted);margin-bottom:6px}
    label{display:block;font-size:12px;color:var(--muted);margin:6px 0 4px}
    input,select,button{
      width:100%;max-width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);
      background:#0f1219;color:var(--fg);appearance:none
    }
    .row{display:grid;grid-template-columns:repeat(12,1fr);gap:10px}
    .col-6{grid-column:span 6}.col-12{grid-column:span 12}
    .btn{cursor:pointer;font-weight:600}.btn:hover{background:#1a1f2b}
    .btn-accent{border-color:#1f3b2f;background:#0f2b22}
    .small{font-size:12px}.muted{color:var(--muted)}
    #msg{min-height:18px}
    .leaflet-top.leaflet-right{margin-right:12px;margin-top:12px}
    .leaflet-top.leaflet-left{margin-left:12px;margin-top:12px}

    /* default pole label look */
    .leaflet-tooltip.pole-tag{
      background:#fff;border:1px solid #e5e7eb;color:#111827;
      box-shadow:0 4px 10px rgba(0,0,0,.12);
      border-radius:8px;padding:4px 6px;font-size:10px;line-height:1.15
    }
    .pole-tag .id{font-weight:700}
    .pole-tag .status{color:#374151}
    .leaflet-tooltip.pole-tag.selected{ background:#2563eb;border-color:#2563eb;color:#fff; }
    .leaflet-tooltip.pole-tag.selected .status{color:#e5efff}
    .leaflet-tooltip.pole-tag.selected .id{color:#fff}

    .hint{font-size:11px;color:var(--muted);margin-top:6px}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <div class="hdr" id="jobName">Job: —</div>
    <div class="small muted" id="selInfo" style="margin-bottom:8px">Selected poles: 0</div>

    <div class="row">
      <div class="col-12">
        <label>Mode</label>
        <select id="mode">
          <option value="assign">Assign new permits (only poles with no permits)</option>
          <option value="modify">Modify existing permits (status only)</option>
        </select>
      </div>

      <div class="col-12 assign-only">
        <label>Base Permit ID (we append “_SCID”)</label>
        <input id="baseId" placeholder="e.g., BTX02-F36_BRN02-F05_SEG2"/>
      </div>

      <div class="col-6">
        <label>Permit Status</label>
        <select id="status">
          <option>Created - NOT Submitted</option>
          <option>Submitted - Pending</option>
          <option>Approved</option>
          <option>Not Approved - Cannot Attach</option>
          <option>Not Approved - PLA Issues</option>
          <option>Not Approved - MRE Issues</option>
          <option>Not Approved - Other Issues</option>
        </select>
      </div>
      <div class="col-6 assign-only">
        <label>Submitted By</label>
        <input id="by" placeholder="Name"/>
      </div>
      <div class="col-6 assign-only">
        <label>Submitted At</label>
        <input id="date" type="date"/>
      </div>

      <!-- Notes (optional; used when Assign/Modify). If empty, do nothing -->
      <div class="col-12">
        <label>Notes (optional — used on Assign/Modify)</label>
        <input id="notes" placeholder="Add or overwrite permit notes for selected poles"/>
      </div>

      <div class="col-6"><label>&nbsp;</label><button id="btnClear" type="button">Clear Selection</button></div>
      <div class="col-6" style="display:flex;gap:8px">
        <button id="btnApply" class="btn btn-accent" type="button" style="flex:1">Apply to Selected Poles</button>
        <button id="btnDelete" class="btn" type="button" style="flex:1;border-color:#7f1d1d;background:#1f2937;color:#fca5a5">Delete Selected Permits</button>
      </div>

      <div class="col-12"><div id="msg" class="small muted" style="margin-top:2px"></div></div>
      <div class="col-12"><div class="hint">Use the polygon/rectangle tools (top-right) to draw one or more areas. Selected labels turn <b style="color:#2563eb">blue</b>.</div></div>
    </div>
  </div>

  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <!-- Capture the Leaflet map instance created by your map.js -->
  <script>
  (function(){
    if (window.L && !window.__L_MAP_WRAPPED__) {
      window.__L_MAP_WRAPPED__ = true;
      const _map = L.map;
      L.map = function(){
        const m = _map.apply(this, arguments);
        window.__leaflet_map__ = m;
        return m;
      };
    }
  })();
  </script>

  <!-- shared config + map logic + watcher graphics (unchanged) -->
  <script src="assets/js/config.js?v=api2"></script>
  <script src="assets/js/map.js"></script>
  <script src="assets/js/watch.js"></script>

  <!-- === Permit Areas overlay (precise, no-touch per prefix) + TOP-RIGHT pro toggle + Pole Labels cycler === -->
  <script>
  (function(){
    'use strict';

    /* ================= Tunables (same behavior you approved) ================= */
    const EPS_CLAMP_MIN_M     = 30;
    const EPS_CLAMP_MAX_M     = 160;
    const MAXEDGE_MIN_M       = 60;
    const MAXEDGE_FACTOR      = 1.9;
    const MST_LINE_BUF_F      = 0.35;
    const POINT_BUF_F         = 0.33;
    const BASE_BUFFER_M       = 10;
    const SIMPLIFY_TOL_M      = 3;
    const MORPH_CLOSE_M       = 2;
    const VOR_MARGIN_M        = 600;
    const CLEAR_GAP_M         = 8;
    const RECOVER_F           = 0.45;

    const POLY_STYLE = { color:'#7b61ff', weight:2, opacity:0.95, fillOpacity:0.10, dashArray:'6,4' };

    /* ================= Helpers ================= */
    const degPerMeterLat = 1 / 111320;
    const degTol = SIMPLIFY_TOL_M * degPerMeterLat;
    const getJob = () => new URLSearchParams(location.search).get('job') || '';

    function isLeafletMap(m){
      return !!(m && typeof m.addControl === 'function' && typeof m.addLayer === 'function' &&
                typeof m.getCenter === 'function' && m._leaflet_id != null);
    }
    function mapInstance(){
      if (isLeafletMap(window.__leaflet_map__)) return window.__leaflet_map__;
      for (const k of Object.keys(window)){ try{ const v = window[k]; if (isLeafletMap(v)) return v; }catch(_){} }
      return null;
    }

    const getLat = o => o?.lat ?? o?.latitude ?? o?.Latitude ?? o?.LAT ?? null;
    const getLng = o => o?.lng ?? o?.lon ?? o?.longitude ?? o?.Longitude ?? o?.LON ?? o?.LONG ?? null;
    function readPermitId(r){ return r?.permit_id ?? r?.permitId ?? r?.permit_no ?? r?.permit_number ?? r?.permit ?? r?.Permit ?? r?.id ?? null; }
    function toPrefix(id){ if (!id || typeof id !== 'string') return null; let s=id.trim(); while (/_\d+$/.test(s)) s=s.replace(/_\d+$/,''); return s; }
    async function smartFetch(paths){ for (const p of paths){ try{ const r=await fetch(p,{cache:'no-store'}); if(r.ok) return r.json(); }catch(_){} } return null; }

    // Normalize SCID: "001" -> "1", 1 -> "1"
    function normSCID(v){ const n = parseInt(v, 10); return Number.isFinite(n) ? String(n) : String(v).replace(/^0+/, ''); }
    // expose for second script
    window.__normSCID = normSCID;

    // (job, SCID) join – robust to tag issues
    function buildPointsFromSTATE(job){
      const S = window.STATE || {};
      const poles   = Array.isArray(S.poles)   ? S.poles   : [];
      const permits = Array.isArray(S.permits) ? S.permits : [];

      const byScid = new Map();
      for (const r of permits){
        if (String(r?.job_name) !== String(job)) continue;
        const key = `${r.job_name}::${normSCID(r?.SCID)}`;
        if (!byScid.has(key)) byScid.set(key, []);
        byScid.get(key).push(r);
      }

      const pts = [];
      for (const p of poles){
        if (job && String(p.job_name) !== String(job)) continue;
        const lat=+getLat(p), lng=+getLng(p); if(!Number.isFinite(lat)||!Number.isFinite(lng)) continue;

        const key = `${p.job_name}::${normSCID(p?.SCID)}`;
        const rel = byScid.get(key) || [];
        for (const r of rel){
          const id = readPermitId(r);
          const prefix = toPrefix(String(id||''));
          if (prefix) pts.push({lat,lng,prefix});
        }
      }
      return pts;
    }

    async function buildPointsFromFiles(job){
      const base = ["data","./data","."];
      const polesP   = base.map(p=>`${p}/poles.json`).concat(["poles.json","./poles.json"]);
      const permitsP = base.map(p=>`${p}/permits.json`).concat(["permits.json","./permits.json"]);
      const [poles,permits] = await Promise.all([ smartFetch(polesP), smartFetch(permitsP) ]);

      const pts = [];
      const byScid = new Map();
      if (Array.isArray(permits)) for (const r of permits){
        if (String(r?.job_name) !== String(job)) continue;
        const key = `${r.job_name}::${normSCID(r?.SCID)}`;
        if (!byScid.has(key)) byScid.set(key, []);
        byScid.get(key).push(r);
      }

      if (Array.isArray(poles)) for (const p of poles){
        if (job && String(p.job_name) !== String(job)) continue;
        const lat=+getLat(p), lng=+getLng(p); if(!Number.isFinite(lat)||!Number.isFinite(lng)) continue;

        const key = `${p.job_name}::${normSCID(p?.SCID)}`;
        const rel = byScid.get(key) || [];
        for (const r of rel){
          const id = readPermitId(r);
          const prefix = toPrefix(String(id||''));
          if (prefix) pts.push({lat,lng,prefix});
        }
      }
      return pts;
    }

    // geometry helpers (MST, Voronoi, etc.)
    function percentile(sorted,p){ if(!sorted.length) return 0; const i=(sorted.length-1)*p; const lo=Math.floor(i), hi=Math.ceil(i); return lo===hi?sorted[lo]:sorted[lo]+(sorted[hi]-sorted[lo])*(i-lo); }
    function nearestNeighborMeters(coords){
      const out=[]; for(let i=0;i<coords.length;i++){ let best=Infinity;
        for(let j=0;j<coords.length;j++){ if(i===j) continue; const d=turf.distance(coords[i],coords[j],{units:'meters'}); if(d<best) best=d; }
        if(Number.isFinite(best)) out.push(best);
      }
      return out.sort((a,b)=>a-b);
    }
    function adaptiveEpsMeters(coords){
      if (coords.length<2) return 50;
      const nnd = nearestNeighborMeters(coords);
      const p50=percentile(nnd,0.50), p75=percentile(nnd,0.75);
      let eps = Math.max(p75*1.5, p50*1.7);
      return Math.min(Math.max(eps, EPS_CLAMP_MIN_M), EPS_CLAMP_MAX_M);
    }
    function mstEdges(coords){
      const n = coords.length; if (n<=1) return [];
      const inMST=new Array(n).fill(false), dist=new Array(n).fill(Infinity), parent=new Array(n).fill(-1);
      dist[0]=0;
      for(let k=0;k<n;k++){
        let u=-1, best=Infinity; for(let i=0;i<n;i++){ if(!inMST[i] && dist[i]<best){ best=dist[i]; u=i; } }
        if(u===-1) break; inMST[u]=true;
        for(let v=0; v<n; v++){
          if(inMST[v]) continue;
          const d=turf.distance(coords[u], coords[v], {units:'meters'});
          if(d<dist[v]){ dist[v]=d; parent[v]=u; }
        }
      }
      const edges=[]; for(let v=1; v<n; v++){ if(parent[v]!==-1) edges.push([coords[v], coords[parent[v]]]); }
      return edges;
    }

    function ensureUIStyles(){
      if (document.getElementById('permit-pill-css')) return;
      const s = document.createElement('style'); s.id='permit-pill-css';
      s.textContent = `
        .permit-pill{background:#000;color:#e11d48;border:1px solid rgba(255,255,255,.28);
          padding:4px 8px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,.35);
          font-weight:800;white-space:nowrap;}
        @keyframes permitBlink{0%{opacity:.60} 50%{opacity:1} 100%{opacity:.60}}
        .permit-blink{animation:permitBlink 1.2s ease-in-out infinite;}

        .overlay-ctl{background:#fff;padding:10px 12px;border-radius:10px;box-shadow:0 1px 3px rgba(0,0,0,.2);min-width:180px}
        .overlay-ctl .row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin:6px 0}
        .overlay-ctl .label{font:600 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial;color:#6b7280}
        .overlay-ctl .small{font:500 11px/1.2 system-ui;color:#9ca3af}

        .switch{position:relative;display:inline-block;width:42px;height:24px}
        .switch input{display:none}
        .slider{position:absolute;inset:0;background:#e5e7eb;border-radius:9999px;transition:background .2s ease;box-shadow:inset 0 0 0 1px rgba(0,0,0,.06)}
        .slider:before{content:"";position:absolute;width:18px;height:18px;left:3px;top:3px;background:#fff;border-radius:50%;transition:transform .2s ease;box-shadow:0 1px 2px rgba(0,0,0,.25)}
        .switch input:checked + .slider{background:#2563eb}
        .switch input:checked + .slider:before{transform:translateX(18px)}

        .ctl-btn{appearance:none;border:1px solid #e5e7eb;background:#f9fafb;border-radius:8px;padding:6px 10px;font:600 12px system-ui;color:#111827;cursor:pointer}
        .ctl-btn:hover{background:#eef2ff;border-color:#c7d2fe}

        /* label cycling */
        #map.labels-scid .leaflet-tooltip.pole-tag:not(.scid-only){ display:none !important; }
        #map.labels-none .leaflet-tooltip.pole-tag{ display:none !important; }
      `;
      document.head.appendChild(s);
    }

    function prefixPolygon(feats){
      const coords = feats.map(f=>f.geometry.coordinates);
      const eps = adaptiveEpsMeters(coords);
      const subFC = turf.featureCollection(feats);
      const maxEdge = Math.max(MAXEDGE_MIN_M, eps * MAXEDGE_FACTOR);

      let poly = (feats.length >= 3) ? turf.concave(subFC, {maxEdge, units:'meters'}) : null;
      if (!poly) poly = (feats.length >= 3) ? turf.convex(subFC) : null;

      const edges = mstEdges(coords);
      let corridor = null;
      const lineW = Math.max(5, eps * MST_LINE_BUF_F);
      for (const e of edges){
        const ls = turf.lineString(e);
        const b  = turf.buffer(ls, lineW, {units:'meters'});
        corridor = corridor ? (turf.union(corridor, b) || corridor) : b;
      }

      let pbuf = null;
      const rPoint = Math.max(5, eps * POINT_BUF_F);
      for (const f of feats){
        const b = turf.buffer(f, rPoint, {units:'meters'});
        pbuf = pbuf ? (turf.union(pbuf, b) || pbuf) : b;
      }

      let merged = null;
      for (const g of [poly, corridor, pbuf]){ if(!g) continue; merged = merged ? (turf.union(merged, g) || merged) : g; }
      if (!merged) return { geom:null, eps };

      try { merged = turf.buffer(merged, MORPH_CLOSE_M, {units:'meters'}); merged = turf.buffer(merged, -MORPH_CLOSE_M, {units:'meters'}); } catch(_){}
      try { merged = turf.buffer(merged, BASE_BUFFER_M, {units:'meters'}); } catch(_){}
      try { merged = turf.simplify(merged, {tolerance: degTol, highQuality:false}); } catch(_){}

      return { geom: merged, eps };
    }

    const coordKey = (lng,lat) => `${lng.toFixed(6)},${lat.toFixed(6)}`;
    function buildVoronoiMap(allPoints){
      const feats = allPoints.map(p => turf.point([p.lng, p.lat], { key: coordKey(p.lng,p.lat) }));
      if (!feats.length) return new Map();
      const fc = turf.featureCollection(feats);
      const bbox = turf.bbox(turf.buffer(fc, VOR_MARGIN_M, {units:'meters'}));
      const vor  = turf.voronoi(fc, { bbox });
      const map = new Map();
      if (vor && Array.isArray(vor.features)){
        for (const cell of vor.features){
          if (!cell) continue;
          for (const f of feats){
            const k = f.properties.key;
            if (map.has(k)) continue;
            try { if (turf.booleanPointInPolygon(f, cell)) { map.set(k, cell); } } catch(_){}
          }
        }
      }
      return map;
    }

    function buildAreasLayer(points){
      const byPrefix = new Map();
      for (const pt of points){ if(!pt||!pt.prefix) continue; if(!byPrefix.has(pt.prefix)) byPrefix.set(pt.prefix, []); byPrefix.get(pt.prefix).push(pt); }
      if (!byPrefix.size) return L.layerGroup();

      const vorMap = buildVoronoiMap(points);
      const layer = L.layerGroup();

      byPrefix.forEach((pts, prefix) => {
        const feats = pts.map(p=>turf.point([p.lng,p.lat], p));
        const { geom:rawGeom } = prefixPolygon(feats);
        if (!rawGeom) return;

        let ownCells = null;
        for (const p of pts){ const cell = vorMap.get(coordKey(p.lng,p.lat)); if (!cell) continue; ownCells = ownCells ? (turf.union(ownCells, cell) || ownCells) : cell; }
        if (!ownCells) return;

        let constrained = null; try { constrained = turf.intersect(rawGeom, ownCells) || ownCells; } catch(_){ constrained = ownCells; }
        let safe = constrained; try { safe = turf.buffer(constrained, -CLEAR_GAP_M, {units:'meters'}); safe = turf.intersect(safe, ownCells) || safe; } catch(_){}

        const erodedCells = (() => { try { return turf.buffer(ownCells, -CLEAR_GAP_M, {units:'meters'}); } catch(_){ return ownCells; }})();
        const recoverR = Math.max(2, CLEAR_GAP_M * RECOVER_F);
        for (const p of pts){
          const pt = turf.point([p.lng,p.lat]);
          try{
            if (!turf.booleanPointInPolygon(pt, safe)) {
              const disk = turf.buffer(pt, recoverR, {units:'meters'});
              const clipped = turf.intersect(disk, erodedCells);
              if (clipped) safe = turf.union(safe, clipped) || safe;
            }
          }catch(_){}
        }

        const gj = L.geoJSON(safe, { style: POLY_STYLE, interactive:false });
        layer.addLayer(gj);

        const pin = turf.pointOnFeature(safe).geometry.coordinates;
        const html = `<div class="permit-pill permit-blink"><span>${prefix}</span></div>`;
        const lbl  = L.marker([pin[1], pin[0]], { icon: L.divIcon({ className:'', html, iconAnchor:[0,0] }), interactive:false, keyboard:false });
        layer.addLayer(lbl);
      });

      return layer;
    }

    /* ================= SCID-only labels overlay (for cycling) ================= */
    async function gatherPoles(){
      const job = getJob();
      const S = window.STATE || {};
      if (Array.isArray(S.poles) && S.poles.length){
        return S.poles.filter(p => !job || String(p.job_name) === String(job));
      }
      const base = ["data","./data","."];
      const polesP = base.map(p=>`${p}/poles.json`).concat(["poles.json","./poles.json"]);
      const all = await smartFetch(polesP) || [];
      return all.filter(p => !job || String(p.job_name) === String(job));
    }

    function buildScidLayer(poles){
      const g = L.layerGroup();
      for (const p of poles){
        const lat = +getLat(p), lng = +getLng(p);
        const scid = (p && p.SCID != null) ? String(p.SCID) : null;
        if (!Number.isFinite(lat) || !Number.isFinite(lng) || !scid) continue;

        const tt = L.tooltip({
          permanent: true,
          direction: 'right',
          offset: [8, 0],
          className: 'pole-tag scid-only'
        })
        .setContent(`SCID ${scid}`)
        .setLatLng([lat, lng]);

        g.addLayer(tt);
      }
      return g;
    }

    // NEW: append Notes under status in normal label mode (join by job+SCID)
    function augmentLabelsWithNotes(){
      const job = getJob();
      const st = window.STATE || {};
      const permits = Array.isArray(st.permits) ? st.permits : [];
      const notesBy = new Map();
      for (const r of permits){
        if (String(r?.job_name) !== String(job)) continue;
        const note = (r?.notes ?? r?.Notes ?? '').toString().trim();
        if (!note) continue;
        const key = `${r.job_name}::${normSCID(r?.SCID)}`;
        if (!notesBy.has(key)) notesBy.set(key, note);
      }
      const tips = document.querySelectorAll('.leaflet-tooltip.pole-tag:not(.scid-only)');
      tips.forEach(tip => {
        const text = tip.textContent || '';
        const m = text.match(/SCID\s+(\d+)/i);
        if (!m) return;
        const scidKey = `${job}::${normSCID(m[1])}`;
        const old = tip.querySelector('.notes-line'); if (old) old.remove();
        const note = notesBy.get(scidKey);
        if (note){
          const div = document.createElement('div');
          div.className = 'notes-line';
          div.style.cssText = 'margin-top:2px;color:#111827;';
          div.textContent = note;
          tip.appendChild(div);
        }
      });
    }

    let labelMode = 'normal'; // normal → scid → none

    async function setLabelMode(mode){
      labelMode = mode;
      const mapDiv = document.getElementById('map');
      if (!mapDiv) return;
      mapDiv.classList.remove('labels-scid','labels-none');
      const map = mapInstance(); if (!isLeafletMap(map)) return;

      if (mode === 'scid') {
        if (window.__scidLabelsLayer && map.hasLayer(window.__scidLabelsLayer)) map.removeLayer(window.__scidLabelsLayer);
        window.__scidLabelsLayer = null;
        const poles = await gatherPoles();
        window.__scidLabelsLayer = buildScidLayer(poles);
        if (!map.hasLayer(window.__scidLabelsLayer)) window.__scidLabelsLayer.addTo(map);
        mapDiv.classList.add('labels-scid');
      } else {
        if (window.__scidLabelsLayer && map.hasLayer(window.__scidLabelsLayer)) map.removeLayer(window.__scidLabelsLayer);
        if (mode === 'none') {
          mapDiv.classList.add('labels-none');
        } else {
          augmentLabelsWithNotes();
        }
      }

      const btn = document.getElementById('labelCycleBtn');
      if (btn) btn.textContent = `Pole Labels: ${mode === 'normal' ? 'Normal' : mode === 'scid' ? 'SCID only' : 'None'}`;
    }
    function cycleLabelMode(){
      if (labelMode === 'normal') setLabelMode('scid');
      else if (labelMode === 'scid') setLabelMode('none');
      else setLabelMode('normal');
    }
    async function rebuildScidLayer(){
      const map = mapInstance(); if (!isLeafletMap(map)) return;
      if (window.__scidLabelsLayer && map.hasLayer(window.__scidLabelsLayer)) map.removeLayer(window.__scidLabelsLayer);
      window.__scidLabelsLayer = null;
      if (labelMode === 'scid') {
        const poles = await gatherPoles();
        window.__scidLabelsLayer = buildScidLayer(poles);
        if (!map.hasLayer(window.__scidLabelsLayer)) window.__scidLabelsLayer.addTo(map);
      }
    }

    async function gatherPoints(){
      const S = window.STATE || {};
      const hasSTATE = Array.isArray(S.poles) && Array.isArray(S.permits) && (S.poles.length || S.permits.length);
      if (hasSTATE) return buildPointsFromSTATE(getJob());
      return buildPointsFromFiles(getJob());
    }
    async function rebuildAreas(){
      const map = mapInstance();
      if (!isLeafletMap(map) || !window.L) return;
      if (window.__permitAreasLayer && map.hasLayer(window.__permitAreasLayer)) map.removeLayer(window.__permitAreasLayer);
      ensureUIStyles();
      const points = await gatherPoints();
      const layer  = buildAreasLayer(points);
      window.__permitAreasLayer = layer;
      const toggle = document.getElementById('permitAreasSwitch');
      const isOn = !toggle || toggle.checked;
      if (isOn && layer) layer.addTo(map);
    }

    const OverlayControl = L.Control.extend({
      onAdd: function(){
        const div = L.DomUtil.create('div', 'overlay-ctl');
        div.innerHTML = `
          <div class="row">
            <span class="label">Permit Areas</span>
            <label class="switch" title="Toggle permit areas">
              <input type="checkbox" id="permitAreasSwitch" checked />
              <span class="slider"></span>
            </label>
          </div>
          <div class="row">
            <button id="labelCycleBtn" class="ctl-btn" title="Cycle pole labels: Normal → SCID only → None">Pole Labels: Normal</button>
          </div>
          <div class="small" style="margin-top:2px">Single, precise, non-touch areas per prefix</div>
        `;
        return div;
      }
    });

    function wireControl(map){
      const sw = document.getElementById('permitAreasSwitch');
      if (sw){
        sw.addEventListener('change', ()=>{
          const layer = window.__permitAreasLayer;
          if (!layer) return;
          if (sw.checked) { if (!map.hasLayer(layer)) layer.addTo(map); }
          else { if (map.hasLayer(layer)) map.removeLayer(layer); }
        });
      }
      const btn = document.getElementById('labelCycleBtn');
      if (btn) btn.addEventListener('click', cycleLabelMode);
    }

    async function boot(){
      const map = mapInstance();
      if (!isLeafletMap(map) || !window.L) { setTimeout(boot, 200); return; }
      const ctl = new OverlayControl({ position: 'topright' });
      map.addControl(ctl);

      const wait = () => {
        if (document.getElementById('permitAreasSwitch') && document.getElementById('labelCycleBtn')) {
          wireControl(map);
          rebuildAreas();
          setLabelMode('normal'); // initial
          setTimeout(augmentLabelsWithNotes, 150);
        } else setTimeout(wait, 100);
      };
      wait();

      window.addEventListener('data:loaded',   ()=>{ rebuildAreas(); rebuildScidLayer(); augmentLabelsWithNotes(); });
      window.addEventListener('poles:loaded',  ()=>{ rebuildAreas(); rebuildScidLayer(); augmentLabelsWithNotes(); });
      window.addEventListener('permits:loaded',()=>{ rebuildAreas(); rebuildScidLayer(); augmentLabelsWithNotes(); });
      window.addEventListener('state:updated', ()=>{ rebuildAreas(); rebuildScidLayer(); augmentLabelsWithNotes(); });

      window.refreshPermitAreas = rebuildAreas;
      window.refreshScidLabels  = rebuildScidLayer;
    }

    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
    else boot();

  })();
  </script>

  <!-- === Mass Notes + Delete Selected Permits (+ immediate SHA refresh) === -->
  <script>
  (function(){
    'use strict';

    const getJob = () => new URLSearchParams(location.search).get('job') || '';
    const S = () => (window.STATE || {});
    const readStatus = r => r?.status ?? r?.permit_status ?? r?.PermitStatus ?? r?.['Permit Status'] ?? r?.Status ?? '(no status)';
    const setMsg = txt => { const el = document.getElementById('msg'); if (el) el.textContent = txt; };
    const normSCID = window.__normSCID || function(v){ const n = parseInt(v,10); return Number.isFinite(n) ? String(n) : String(v).replace(/^0+/, ''); };

    /* ---- SHA-mode refresh helpers ---- */
    const GH = () => (window.APP_CONFIG || {}); // {OWNER, REPO, DEFAULT_BRANCH, DATA_DIR}

    async function ghBranchHeadSha(){
      const cfg = GH(); if (!cfg.OWNER) return null;
      const br = cfg.DEFAULT_BRANCH || 'main';
      const r = await fetch(`https://api.github.com/repos/${cfg.OWNER}/${cfg.REPO}/branches/${br}`, {cache:'no-store'});
      if (!r.ok) return null;
      const j = await r.json();
      return j?.commit?.sha || null;
    }
    async function ghFindBlobSha(headSha, path){
      const cfg = GH(); if (!cfg.OWNER || !headSha) return null;
      const r = await fetch(`https://api.github.com/repos/${cfg.OWNER}/${cfg.REPO}/git/trees/${headSha}?recursive=1`, {cache:'no-store'});
      if (!r.ok) return null;
      const j = await r.json();
      const item = (j?.tree || []).find(t => t.type === 'blob' && t.path === path);
      return item?.sha || null;
    }
    async function ghFetchJsonByBlobSha(blobSha){
      const cfg = GH(); if (!cfg.OWNER || !blobSha) return null;
      const r = await fetch(`https://api.github.com/repos/${cfg.OWNER}/${cfg.REPO}/git/blobs/${blobSha}`, {
        headers: { 'Accept': 'application/vnd.github.raw' },
        cache: 'no-store'
      });
      if (!r.ok) return null;
      const txt = await r.text();
      try { return JSON.parse(txt); } catch { return null; }
    }
    async function reloadFromSHA(){
      const cfg = GH();
      const dataDir = cfg.DATA_DIR || 'data';
      try {
        if (cfg.OWNER) {
          const head = await ghBranchHeadSha();
          const [polesBlob, permitsBlob] = await Promise.all([
            ghFindBlobSha(head, `${dataDir}/poles.json`),
            ghFindBlobSha(head, `${dataDir}/permits.json`)
          ]);
          const [poles, permits] = await Promise.all([
            ghFetchJsonByBlobSha(polesBlob),
            ghFetchJsonByBlobSha(permitsBlob)
          ]);
          if (Array.isArray(poles))   window.STATE.poles   = poles;
          if (Array.isArray(permits)) window.STATE.permits = permits;
        } else {
          const [poles, permits] = await Promise.all([
            fetch(`${dataDir}/poles.json`,   {cache:'no-store'}).then(r=>r.ok?r.json():null).catch(()=>null),
            fetch(`${dataDir}/permits.json`, {cache:'no-store'}).then(r=>r.ok?r.json():null).catch(()=>null),
          ]);
          if (Array.isArray(poles))   window.STATE.poles   = poles;
          if (Array.isArray(permits)) window.STATE.permits = permits;
        }
      } catch(e){ /* ignore */ }

      window.dispatchEvent(new Event('data:loaded'));
      window.dispatchEvent(new Event('poles:loaded'));
      window.dispatchEvent(new Event('permits:loaded'));
      window.dispatchEvent(new Event('state:updated'));
      if (window.refreshPermitAreas) window.refreshPermitAreas();
      if (window.refreshScidLabels)  window.refreshScidLabels();
    }
    async function refreshAfterWrite(pollTries=6, pollMs=900){
      const cfg = GH();
      if (!cfg.OWNER) { await reloadFromSHA(); return; }
      const dataDir = cfg.DATA_DIR || 'data';
      const head0 = await ghBranchHeadSha();
      const perm0 = await ghFindBlobSha(head0, `${dataDir}/permits.json`);
      for (let i=0;i<pollTries;i++){
        await new Promise(r=>setTimeout(r, pollMs));
        const head = await ghBranchHeadSha();
        const perm = await ghFindBlobSha(head, `${dataDir}/permits.json`);
        if (head && perm && (head !== head0 || perm !== perm0)) break;
      }
      await reloadFromSHA();
    }
    function kickWatcherNow(){
      try {
        if (window.__githubWatcher && typeof window.__githubWatcher.refresh === 'function') {
          window.__githubWatcher.refresh();
        }
        window.dispatchEvent(new Event('github:refresh-now'));
        window.dispatchEvent(new Event('watch:refresh-now'));
      } catch(_) {}
    }

    /* ---- selection ---- */
    // REPLACE your current getSelectedSCIDs() with this version
    function getSelectedSCIDs(){
      // 0) Normalizer already shared from the first script
      const ns = (v) => normSCID(v);

      // 1) Prefer selection from global state, if your map.js exposes it
      const W = window;
      const candidates = [
        W.SELECTED_SCIDS,
        W.SELECTION_SCIDS,
        W.SELECTION?.scids,
        W.SELECTION?.ids,
        W.STATE?.selectedScids,
        W.STATE?.selection?.scids,
        W.STATE?.selected?.scids
      ].filter(Boolean);

      for (const arr of candidates){
        if (Array.isArray(arr) && arr.length){
          return [...new Set(arr.map(ns))];
        }
      }

      // 2) DOM: labels explicitly marked as selected
      let ids = new Set();
      document.querySelectorAll('.leaflet-tooltip.pole-tag.selected').forEach(el=>{
        const m = (el.textContent || '').match(/SCID\s+(\d+)/i);
        if (m) ids.add(ns(m[1]));
      });
      if (ids.size) return [...ids];

      // 3) DOM fallback: compute style (blue-ish bg) OR has 'selected' anyway
      document.querySelectorAll('.leaflet-tooltip.pole-tag').forEach(el=>{
        const cs = window.getComputedStyle(el);
        const bg = (cs.backgroundColor || '').replace(/\s+/g,'').toLowerCase();
        // rgb(37,99,235) ~= #2563eb — allow a loose check
        const looksSelected = bg.includes('37,99,235') || el.classList.contains('selected');
        if (looksSelected){
          const m = (el.textContent || '').match(/SCID\s+(\d+)/i);
          if (m) ids.add(ns(m[1]));
        }
      });
      return [...ids];
    }


    /* ---- Mass-apply Notes (no SCID appending) ---- */
    function massApplyNotesToSelected(){
      const notes = (document.getElementById('notes')?.value || '').trim();
      if (!notes) return;

      const job = getJob();
      const scids = new Set(getSelectedSCIDs());
      const st = S();
      if (!Array.isArray(st.permits) || !scids.size) return;

      let changed = 0;
      for (const r of st.permits){
        if (String(r?.job_name) === String(job) && scids.has(normSCID(r?.SCID))){
          if ('notes' in r) { if (r.notes !== notes) { r.notes = notes; changed++; } }
          else if ('Notes' in r) { if (r.Notes !== notes) { r.Notes = notes; changed++; } }
          else { r.notes = notes; changed++; }
        }
      }
      if (changed){
        window.dispatchEvent(new Event('permits:loaded'));
        window.dispatchEvent(new Event('state:updated'));
        setMsg(`Notes updated on ${changed} permit${changed===1?'':'s'}.`);
        kickWatcherNow();
        reloadFromSHA();
      }
    }

    function hookApplyForNotes(){
      const btn = document.getElementById('btnApply');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        massApplyNotesToSelected();
        kickWatcherNow();
        await refreshAfterWrite();
      }, false);
    }

    /* ---- Delete flow ---- */
    function openDeleteStatusPicker(statusCounts, onConfirm){
      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.4);z-index:5000;display:flex;align-items:center;justify-content:center';
      const box = document.createElement('div');
      box.style.cssText = 'background:#0f1219;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;min-width:340px;max-width:420px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);font:14px system-ui';
      box.innerHTML = `
        <div style="font-weight:700;margin-bottom:8px">Delete selected permits</div>
        <div style="font-size:12px;color:#9aa3b2;margin-bottom:8px">Choose which <b>statuses</b> to delete from the selected poles.</div>
        <div id="stList" style="display:flex;flex-direction:column;gap:8px;margin:8px 0 12px 0;max-height:220px;overflow:auto"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button id="delCancel" style="padding:8px 10px;border-radius:8px;border:1px solid #334155;background:#111827;color:#e5e7eb;cursor:pointer">Cancel</button>
          <button id="delGo" style="padding:8px 10px;border-radius:8px;border:1px solid #7f1d1d;background:#1f2937;color:#fca5a5;cursor:pointer;font-weight:700">Delete</button>
        </div>
      `;
      const list = box.querySelector('#stList');
      Object.entries(statusCounts).forEach(([st, cnt])=>{
        const id = 'st_' + Math.random().toString(36).slice(2);
        const row = document.createElement('label');
        row.style.cssText = 'display:flex;align-items:center;gap:8px';
        row.innerHTML = `<input type="checkbox" id="${id}" checked/><span>${st}</span><span style="margin-left:auto;color:#9aa3b2">(${cnt})</span>`;
        list.appendChild(row);
        row.querySelector('input').dataset.status = st;
      });
      overlay.appendChild(box);
      document.body.appendChild(overlay);

      function close(){ overlay.remove(); }

      box.querySelector('#delCancel').onclick = close;
      box.querySelector('#delGo').onclick = () => {
        const checks = Array.from(list.querySelectorAll('input[type=checkbox]')).filter(c => c.checked).map(c => c.dataset.status);
        if (!checks.length) { close(); return; }
        const total = Object.entries(statusCounts).filter(([s])=>checks.includes(s)).reduce((a, [,c])=>a+c, 0);
        const ok = window.confirm(`Are you sure you want to delete ${total} permit${total===1?'':'s'} with status: ${checks.join(', ')}?`);
        if (!ok) return;
        close();
        onConfirm(checks);
      };
    }

    async function deleteSelectedPermits(){
      const job = getJob();
      const st = S();
      const scids = new Set(getSelectedSCIDs());
      if (!Array.isArray(st.permits) || !scids.size){
        setMsg('No poles selected with permits to delete.');
        return;
      }
      const candidates = st.permits.filter(r => String(r?.job_name)===String(job) && scids.has(normSCID(r?.SCID)));
      if (!candidates.length){ setMsg('Selected poles have no permits to delete.'); return; }

      const statusCounts = {};
      for (const r of candidates){
        const s = readStatus(r);
        statusCounts[s] = (statusCounts[s]||0) + 1;
      }
      openDeleteStatusPicker(statusCounts, async (chosenStatuses)=>{
        const keep = st.permits.filter(r => !(String(r?.job_name)===String(job) && scids.has(normSCID(r?.SCID)) && chosenStatuses.includes(readStatus(r))));
        const removed = st.permits.length - keep.length;
        if (!removed){ setMsg('Nothing deleted.'); return; }
        window.STATE.permits = keep;

        window.dispatchEvent(new Event('permits:loaded'));
        window.dispatchEvent(new Event('state:updated'));
        if (window.refreshPermitAreas) window.refreshPermitAreas();
        if (window.refreshScidLabels)  window.refreshScidLabels();
        setMsg(`Deleted ${removed} permit${removed===1?'':'s'} from ${scids.size} pole${scids.size===1?'':'s'}.`);

        kickWatcherNow();
        await refreshAfterWrite();
      });
    }

    function init(){
      const del = document.getElementById('btnDelete');
      if (del) del.addEventListener('click', deleteSelectedPermits);
      const apply = document.getElementById('btnApply');
      if (apply) hookApplyForNotes();

      window.addEventListener('permits:saved', reloadFromSHA);
      window.addEventListener('github:commit', reloadFromSHA);
    }

    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
    else init();

  })();
  </script>
</body>
</html>
